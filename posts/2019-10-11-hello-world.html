<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>K32 - Trace-based testing</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlight.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
                <a href="../tags.html">Tags</a>
                <a href="../atom.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h1>Trace-based testing</h1>

            <div class="info">
    
    Posted on October 11, 2019
    
    
</div>
<div class="info">
    
    Tags: <a href="../tags/erlang.html">erlang</a>, <a href="../tags/software%20testing.html">software testing</a>, <a href="../tags/snabbkaffe.html">snabbkaffe</a>
    
</div>

<p>Almost every practical algorithm is non-deterministic by design. Unpredictable process scheduling has to be dealt with in concurrent programs, network reorders and delays messages randomly, and fault-tolerant systems can experience failover at any time. It comes as no surprise to anyone, and most programmers deal with non-determinism on subconscious level. Tests, on the other hand, often ignore or fight this property, which becomes a constant supply of flakiness.</p>
<p>In this post I want to introduce a simple component<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> test <a href="https://github.com/klarna/snabbkaffe">library</a> that tries to embrace non-determinism, or at least live with it. It achieves this by giving up on <em>states</em> and focusing on temporal relations of <em>effects</em> instead: relevant side effects of the algorithm are recorded into a <em>trace</em>, which later gets analyzed for desired properties. Simply speaking, testcase reads the logs of system under test (SUT) in order to find bugs. As a bonus, tests written in this style tend to scale better than traditional ones, in theory and in my own experience.</p>
<p>The idea of using an event trace for verifying properties of concurrent (and distributed) systems is far from new, but it is rather uncommon outside of academia. I will also touch on how trace-based testing compares with more traditional approaches such as stateful property-based testing.</p>
<h1>Conventional approach</h1>
<p>Typical component test usually follows the same common scenario: first a clean test environment is created. This probably involves spinning up Docker containers, initializing tables with test data and so on. Sometimes a testcase mocks functions that are of particular interest, and injects checks inside these mocks. Then a SUT is started. In the simplest case it happens synchronously, but often the testcase has to wait for the steady state by probing, sleeping and retrying.</p>
<p>After startup is done, actual testing can finally begin. This part consists of one or multiple iterations of stimulating the system (via an API call or error injection), followed by checking that it responds to the stimuli as expected. The checking part may again require probing and retrying. It may also involve analyzing data captured by the mocks.</p>
<p>Finally a cleanup stage is run, but it is not that interesting. The below pseudocode illustrates the entire workflow:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb1-1" title="1"><span class="co">%% Preparations:</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">set_up_test_environment(),</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">mock_test_modules(),</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="fu">application:start(</span><span class="ch">tested_app</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">%% Actual testing:</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="fu">?assertMatch(</span><span class="ch">ok</span><span class="fu">,</span> <span class="fu">async_action1()),</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="fu">retry_n_times(check_condition_1()),</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="fu">?assertMatch(</span><span class="ch">ok</span><span class="fu">,</span> <span class="fu">async_action2()),</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="fu">retry_n_times(check_condition_2()),</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="fu">?assertMatch({</span><span class="ch">error</span><span class="fu">,</span> <span class="va">_</span><span class="fu">},</span> <span class="fu">async_action3()),</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="fu">retry_n_times(check_condition_3()),</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="fu">...</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">%% Clean up:</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="fu">application:stop(</span><span class="ch">tested_app</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="fu">tear_down_test_environment()</span></a></code></pre></div>
<p>This basic testing loop can be put together with varying degrees of fanciness, up to stateful <a href="https://proper-testing.github.io/">PropER</a> models, but it doesn't change the core mechanic described above.</p>
<p>So, what is wrong about this basic and familiar design?</p>
<h2>Scalability</h2>
<p>First problem is run time. Obviously, one wants to verify as many different properties as possible. But a complex SUT may require a complex test environment, which can take arbitrarily long time to set up. (Anecdotally, I used to work with a Common Test suite where <code>init_per_testcase</code> callback took a few minutes. The experience was soul-crushing.) Typical response to this challenge, naturally, involves trying to cram as many scenarios into the testcase as possible. Then comes realization that the testcase becomes extremely hard to understand, troubleshoot and extend.</p>
<p>In my experience, there are multiple reasons for this:</p>
<ol>
<li>State deviates too much from the blank slate. Each operation can mutate state of the SUT, and the following checks have to take more and more history into account. Stateful propER suites mitigate this problem by managing model state automatically, but it comes at a significant cost of having to define an elaborate and complete model of the system.</li>
<li><p>Non-determinism starts crawling out a closet. Typical test starts from a known state, and tries to evolve it in extremely controlled fashion, to avoid dealing with multiple outcomes, because there lies combinatorial explosion and loss of sanity.</p>
<p>But natural sources of randomness, that exist in any complex system, tend to sneak into the results more and more over time. As far as I know, stateful propERties can't deal with this, as model state is evolved via symbolic execution that happens before SUT is even started.</p>
This leads to testcase flakiness or unreasonably long waiting until the system stabilizes.</li>
<li><p>Mocks are not composable. If checks are injected into SUT using mock functions, it becomes exceedingly hard to add new checks.</p></li>
</ol>
<p>Conclusion: efficiency of testing could be greatly improved if there was an easy way to validate multiple properties without re-running test scenarios. Trace-based approach solves this problem, because an event trace can be recorded once and analyzed however many times.</p>
<h2>Error detection</h2>
<p>&quot;Retry N times until test condition becomes true and call it a pass&quot; is a pretty common pattern found in tests. Although it works reasonably well most of the time, there are kinds of errors that evade it: livelocks for example. During livelock condition the system may enter &quot;valid&quot; state temporarily, and the testcase designed via retry logic may accept it.</p>
<p>To illustrate how bad it can be, imagine a distributed system consisting of two nodes, where automatic failover can happen. Each node can reside in three possible states, let's call them <code>primary</code>, <code>standby</code> and <code>alone</code>. During normal operation there is one <code>primary</code> and one <code>standby</code> node. The <code>primary</code> instance may fail, in which case the other node changes its state from <code>standby</code> to <code>alone</code>, and takes over the workload. When the failed node recovers, it enters <code>standby</code> state and signals to its partner that it's ready, then the latter enters <code>primary</code> state, and the system becomes redundant again. Now suppose there is a bug, that is triggered shortly after state transition from <code>alone</code> to <code>primary</code> happens. It can lead to a situation where failover becomes cyclic. &quot;Retry until first success&quot; approach will let this error slip through, but this error can be trivially detected in a trace-based test by counting failover events.</p>
<h1>Trace-based approach</h1>
<h2>Prior work</h2>
<p>The below (incomplete!) list contains some examples of libraries using trace-based approach:</p>
<ul>
<li><a href="https://github.com/uwplse/verdi">Verdi</a> is a framework for formal verification of distributed systems using proofs over traces.</li>
<li><a href="https://github.com/jepsen-io/jepsen">Jepsen</a> is test framework for black-box testing of distributed databases. Internally it maintains a log of calls towards SUT, and most properties are verified by traversing this log (at least as far as my ability to read Clojure goes).</li>
</ul>
<h2>Introducing Snabbkaffe</h2>
<p><a href="https://github.com/klarna/snabbkaffe">Snabbkaffe</a> is a small Erlang application inspired by the above libraries. Above all, it tries to be accessible and compatible with other test frameworks, such as Common Test and PropER. It is not rigorous<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>: it can find bugs, but it cannot verify absence of errors.</p>
<h2>Instrumenting the code</h2>
<p>Trace points are added to the code manually using <code>?tp</code> macro:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">?tp(</span><span class="ch">something_happened</span><span class="fu">,</span> <span class="fu">#{</span> <span class="ch">param1</span> <span class="op">=&gt;</span> <span class="st">&quot;Something&quot;</span></a>
<a class="sourceLine" id="cb2-2" title="2">                         <span class="fu">,</span> <span class="ch">param2</span> <span class="op">=&gt;</span> <span class="dv">217</span></a>
<a class="sourceLine" id="cb2-3" title="3">                         <span class="fu">})</span></a></code></pre></div>
<p>The above line of code, when compiled in test mode, emits an event of kind <code>something_happened</code>, with some additional data specified in the second argument. Any event has a kind, which is an atom identifying type of the event. The second argument must be a map that can contain anything.</p>
<p>Exact form of this effect captured in the trace will look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">#{</span> <span class="ch">kind</span>   <span class="op">=&gt;</span> <span class="ch">something_happened</span></a>
<a class="sourceLine" id="cb3-2" title="2"> <span class="fu">,</span> <span class="ch">param1</span> <span class="op">=&gt;</span> <span class="st">&quot;Something&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3"> <span class="fu">,</span> <span class="ch">param2</span> <span class="op">=&gt;</span> <span class="dv">217</span></a>
<a class="sourceLine" id="cb3-4" title="4"> <span class="fu">,</span> <span class="ch">ts</span>     <span class="op">=&gt;</span> <span class="fu">.....</span> <span class="co">% native timestamp</span></a>
<a class="sourceLine" id="cb3-5" title="5"> <span class="fu">}</span></a></code></pre></div>
<p>In the release build this macro will become a <a href="https://github.com/tolbrino/hut">hut</a> log message with debug level. Log level can be tuned with a special form of <code>?tp</code> macro that takes 3 arguments:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">?tp(</span><span class="ch">notice</span><span class="fu">,</span> <span class="ch">something_happened</span><span class="fu">,</span> <span class="fu">#{</span> <span class="ch">param1</span> <span class="op">=&gt;</span> <span class="st">&quot;Something&quot;</span></a>
<a class="sourceLine" id="cb4-2" title="2">                                 <span class="fu">,</span> <span class="ch">param2</span> <span class="op">=&gt;</span> <span class="dv">217</span></a>
<a class="sourceLine" id="cb4-3" title="3">                                 <span class="fu">,</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb4-4" title="4">                                 <span class="fu">})</span></a></code></pre></div>
<p>…Quite literally, snabbkaffe analyzes the logs of the SUT.</p>
<h2>Structure of the testcase</h2>
<p>In order to address scalability issue mentioned above, snabbkaffe decouples execution of test scenario from the checks. Testcases are split in two parts:</p>
<ul>
<li><strong>Run stage</strong> where the program runs and emits an event trace</li>
<li><strong>Check stage</strong> where the trace is collected and validated against the spec(s)</li>
</ul>
<p>To save user from boilerplate of starting <code>snabbkaffe_collector</code> and collecting the trace, <code>?check_trace</code> macro is defined, that takes care of these steps:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">?check_trace(</span><span class="kw">begin</span></a>
<a class="sourceLine" id="cb5-2" title="2">               <span class="co">%% Run stage:</span></a>
<a class="sourceLine" id="cb5-3" title="3">               <span class="va">Result</span></a>
<a class="sourceLine" id="cb5-4" title="4">             <span class="kw">end</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-5" title="5">             <span class="kw">fun</span><span class="fu">(</span><span class="va">Result</span><span class="fu">,</span> <span class="va">Trace</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb5-6" title="6">                <span class="co">%% Check stage:</span></a>
<a class="sourceLine" id="cb5-7" title="7">                <span class="va">CheckStage</span></a>
<a class="sourceLine" id="cb5-8" title="8">             <span class="kw">end</span><span class="fu">).</span></a></code></pre></div>
<p>Return value of the run stage is passed to the check stage function together with the collected trace.</p>
<p>There is also an extended version of this macro, that passes some additional options to <code>snabbkaffe_collector</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">?check_trace(#{</span><span class="ch">timeout</span> <span class="op">=&gt;</span> <span class="va">Timeout</span><span class="fu">},</span></a>
<a class="sourceLine" id="cb6-2" title="2">             <span class="kw">begin</span></a>
<a class="sourceLine" id="cb6-3" title="3">               <span class="va">RunStage</span></a>
<a class="sourceLine" id="cb6-4" title="4">             <span class="kw">end</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-5" title="5">             <span class="kw">fun</span><span class="fu">(</span><span class="va">ReturnValue</span><span class="fu">,</span> <span class="va">Trace</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb6-6" title="6">                <span class="va">CheckStage</span></a>
<a class="sourceLine" id="cb6-7" title="7">             <span class="kw">end</span><span class="fu">).</span></a></code></pre></div>
<p><code>timeout</code> commands collector process to wait for a set period of silence before terminating. It might be useful sometimes, although depending on timeouts opens road to flakiness. There are a few other parameters that are out of scope of this post.</p>
<h2>Analyzing the trace</h2>
<p>Remember that trace analysis is done offline, so any pure function can be used for this task. Snabbakaffe comes with a few useful functions and macros.</p>
<p>Let's begin from my favorite one, called <code>?strict_causality</code>. It verifies that any event matching pattern <code>Cause</code>, is followed by exactly one event that matches pattern <code>Effect</code>. It can be used to encode &quot;something results in another thing&quot; type of properties, here's just a few examples:</p>
<ul>
<li>Every external request entering the system eventually gets processed</li>
<li>Killing a node results in failover</li>
</ul>
<p>Consider an example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">?strict_causality(</span> <span class="fu">#{</span><span class="ch">kind</span> <span class="fu">:</span><span class="op">=</span> <span class="ch">request</span><span class="fu">,</span> <span class="ch">req_id</span> <span class="fu">:</span><span class="op">=</span> <span class="va">_Ref</span><span class="fu">}</span> <span class="co">%% Cause</span></a>
<a class="sourceLine" id="cb7-2" title="2">                 <span class="fu">,</span> <span class="fu">#{</span><span class="ch">kind</span> <span class="fu">:</span><span class="op">=</span> <span class="ch">reply</span><span class="fu">,</span>   <span class="ch">req_id</span> <span class="fu">:</span><span class="op">=</span> <span class="va">_Ref</span><span class="fu">}</span> <span class="co">%% Effect</span></a>
<a class="sourceLine" id="cb7-3" title="3">                 <span class="fu">,</span> <span class="va">Trace</span></a>
<a class="sourceLine" id="cb7-4" title="4">                 <span class="fu">)</span></a></code></pre></div>
<p><code>Cause</code> expression binds variables used in <code>Effect</code> expression, so the above code reads as &quot;for each request with request id equal to <code>_Ref</code> there should be a reply with the same id&quot;.</p>
<p>There is also a sister macro that allows <code>Cause</code> without <code>Effect</code> (but not vice versa), called <code>?causality</code>. It works similarly, although it is used less often. Both <code>?strict_causality</code> and <code>?causality</code> are based on the same powerful macro called <code>?find_pairs</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">?find_pairs(</span><span class="va">Strict</span><span class="fu">,</span> <span class="va">Cause</span><span class="fu">,</span> <span class="va">Effect</span> <span class="fu">[,</span> <span class="va">Guard</span><span class="fu">],</span> <span class="va">Trace</span><span class="fu">)</span></a></code></pre></div>
<p>Where <code>Cause</code> and <code>Effect</code> are pattern match expressions, <code>Guard</code> is an optional predicate that allows to refine cause/effect matching, and <code>Strict</code> is a boolean defining whether or not effects without a cause are allowed. This macro returns a list of pairs of complimentary events and singletons, that can be further analyzed, for example using <code>?pair_max_depth</code> macro, which returns maximal nesting level. This can be used e.g. to verify semaphore-like systems.</p>
<p>A few helper macros for extracting relevant data from the trace deserve mention too. <code>?of_kind([kind1, kind2, ...], Trace)</code>, unsurprisingly, filters events with certain kinds. <code>?projection([field1, field2, ...], Trace)</code> extracts fields from events to make data more manageable.</p>
<p><code>?projection_complete</code> and <code>?projection_is_subset</code> macros check if values of a field form a superset or a subset of a known set. <code>snabbkaffe:unique/1</code> function checks that there are no duplicate events.</p>
<p>In general it is advised to factor complex properties into small manageable functions, like in the below example (taken from a real project and stripped of irrelevant details):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">my_testcase(</span><span class="va">Config</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="va">Values</span> <span class="op">=</span> <span class="fu">...,</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="fu">?check_trace(</span></a>
<a class="sourceLine" id="cb9-4" title="4">     <span class="co">%% Run stage:</span></a>
<a class="sourceLine" id="cb9-5" title="5">     <span class="kw">begin</span></a>
<a class="sourceLine" id="cb9-6" title="6">        <span class="fu">...</span></a>
<a class="sourceLine" id="cb9-7" title="7">     <span class="kw">end</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-8" title="8">     <span class="co">%% Check stage:</span></a>
<a class="sourceLine" id="cb9-9" title="9">     <span class="kw">fun</span><span class="fu">(</span>_<span class="va">Ret</span><span class="fu">,</span> <span class="va">Trace</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb9-10" title="10">         <span class="fu">check_all_messages_were_received_once(</span><span class="va">Trace</span><span class="fu">,</span> <span class="va">Values</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb9-11" title="11">         <span class="fu">check_handler_pids(</span><span class="va">Trace</span><span class="fu">)</span></a>
<a class="sourceLine" id="cb9-12" title="12">     <span class="kw">end</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="fu">check_all_messages_were_received_once(</span><span class="va">Trace</span><span class="fu">,</span> <span class="va">ExpectedValues</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb9-15" title="15">  <span class="va">Handled</span> <span class="op">=</span> <span class="fu">?of_kind(</span><span class="ch">handle_message</span><span class="fu">,</span> <span class="va">Trace</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb9-16" title="16">  <span class="co">%% Check that all messages were handled:</span></a>
<a class="sourceLine" id="cb9-17" title="17">  <span class="fu">?projection_complete(</span><span class="ch">value</span><span class="fu">,</span> <span class="va">Handled</span><span class="fu">,</span> <span class="va">ExpectedValues</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb9-18" title="18">  <span class="co">%% ...and each message was handled only once:</span></a>
<a class="sourceLine" id="cb9-19" title="19">  <span class="fu">snabbkaffe:unique(</span><span class="va">Handled</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb9-20" title="20"></a>
<a class="sourceLine" id="cb9-21" title="21"><span class="fu">check_handler_pids(</span><span class="va">Trace</span><span class="fu">)</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb9-22" title="22">  <span class="co">%% Check that all messages were handled by the same process:</span></a>
<a class="sourceLine" id="cb9-23" title="23">  <span class="va">PidsOfWorkers</span> <span class="op">=</span> <span class="fu">?projection(</span><span class="ch">worker</span><span class="fu">,</span> <span class="fu">?of_kind(</span><span class="ch">handle_message</span><span class="fu">,</span> <span class="va">Trace</span><span class="fu">)),</span></a>
<a class="sourceLine" id="cb9-24" title="24">  <span class="fu">?assertMatch([</span>_<span class="fu">],</span> <span class="fu">lists:usort(</span><span class="va">PidsOfWorkers</span><span class="fu">)).</span></a></code></pre></div>
<h2>Waiting for events</h2>
<p>Run stage often needs to wait for something to happen. This can be needed, for example, when some part of the system is activated asynchronously. Retry loop will still work, of course, but sometimes it's more convenient to wait for a certain trace event. <code>?block_until</code> macro can be used in this situation:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">?check_trace(</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="co">%% Run stage:</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="kw">begin</span></a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="co">%% Some async oparation:</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="fu">spawn(</span><span class="kw">fun</span><span class="fu">()</span> <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb10-6" title="6">            <span class="fu">timer:sleep(</span><span class="dv">100</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb10-7" title="7">            <span class="fu">?tp(</span><span class="ch">started</span><span class="fu">,</span> <span class="fu">#{</span> <span class="fu">...</span> <span class="fu">}),</span></a>
<a class="sourceLine" id="cb10-8" title="8">            <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-9" title="9">          <span class="kw">end</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="va">Timeout</span> <span class="op">=</span> <span class="ch">infinity</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="va">BackInTime</span> <span class="op">=</span> <span class="dv">100</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb10-12" title="12">    <span class="fu">?block_until(#{</span><span class="ch">kind</span> <span class="fu">:</span><span class="op">=</span> <span class="ch">started</span><span class="fu">},</span> <span class="va">Timeout</span><span class="fu">,</span> <span class="va">BackInTime</span><span class="fu">),</span></a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-14" title="14">  <span class="kw">end</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb10-15" title="15">  <span class="fu">...</span></a></code></pre></div>
<p><code>?block_until</code> macro works like this: first it tries to find an event in the history, going at most <code>BackInTime</code> milliseconds into the past. If this succeeds, execution continues immediately, otherwise calling process gets blocked until the event arrives or crashes after timeout.</p>
<p>Although this macro can cover most scenarios, tuning two timings may be tricky and error-prone. There is a more &quot;atomic&quot; version of this macro, named <code>?wait_async_action</code>, which doesn't have to look into the past:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb11-1" title="1"><span class="fu">?wait_async_action(</span><span class="va">Action</span><span class="fu">,</span> <span class="va">Match</span><span class="fu">,</span> <span class="va">Timeout</span><span class="fu">)</span></a></code></pre></div>
<p>It starts waiting for <code>Action</code>'s expected outcome event <code>Match</code> before running it.</p>
<h2>PropER integration</h2>
<p>Snabbkaffe works nicely with PropER. <code>?check_trace</code> macro can be used to define stateless properties, and there is, in fact, a shortcut for the most common way of doing this: <code>?forall_trace</code>. But when it comes to stateful properties, things get more interesting on the philosophical layer.</p>
<p>Stateful property based testing is an object of pride in the Erlang community, and rightfully so. Nonetheless, I would argue that trace-based approach is more efficient in the majority of cases. First of all, remember that snabbkaffe strives to eliminate the state from the equation and focus on effects. This makes trace-based and stateful property-based testing almost mutually exclusive. For black-box and gray-box testing<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>, side effects is all what matters, so snabbkaffe fills this niche. On the other hand, stateful properties are much better at increasing test coverage.</p>
<p>The below table highlights some of the benefits of each solution:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Stateful propER</th>
<th>snabbkaffe</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Purpose</td>
<td>white-box</td>
<td>black and gray-box</td>
</tr>
<tr class="even">
<td>Can handle non-determinism</td>
<td>no</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>Elaborate model is needed</td>
<td>yes</td>
<td>not necessarily</td>
</tr>
<tr class="even">
<td>Can reliably explore all states of the system</td>
<td>yes, with good enough model</td>
<td>no</td>
</tr>
<tr class="odd">
<td>Shrinking</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="even">
<td>Amount of boilerplate</td>
<td>high (need to define a lot of callbacks)</td>
<td>low</td>
</tr>
</tbody>
</table>
<h1>Future posts</h1>
<p>Here's a teaser of what's coming:</p>
<ul>
<li>Declarative error injection</li>
<li>Rigorous trace-based models using <a href="https://github.com/parapluu/Concuerror">Concuerror</a></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Since test levels are defined somewhat vaguely, here by &quot;component test&quot; I mean testing of an entire OTP application, complete with its supervisor tree, application dependencies and external services that this application is meant to communicate with (e.g. databases).<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>But running it under Concuerror might partially mitigate this<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>…And for your customers. They can't observe the internal state of the system, but they sure care about side effects of their actions!<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>

        </div>
    </body>
</html>
