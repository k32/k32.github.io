<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>k32's notebook</title>
<description>A collection of articles in RSS</description>
<generator>Emacs webfeeder.el</generator>
<link>https://blog.erlang.moe/</link>
<atom:link href="https://blog.erlang.moe/atom.xml" rel="self" type="application/rss+xml"/>
<lastBuildDate>m√•n, 17 maj 2021 12:29:03 +0200</lastBuildDate>
<item>
  <title>Mnesia internals</title>
  <description><![CDATA[<div id="content">

 <p>
I've been studying Mnesia internals lately, and I figured I may start publishing my scattered notes.
I will keep updating this post with more details.
</p>

 <p>
Disclaimer: I am not an OTP dev, and not a mnesia dev.
Anything that will be posted here will be derived from reading the code.
</p>

 <p>
Pictures contain clickable links.
</p>

 <div id="outline-container-org850463c" class="outline-2">
 <h2 id="org850463c"> <span class="section-number-2">1</span> Transaction</h2>
 <div class="outline-text-2" id="text-1">
 <p>
Transaction fun runs in the same process that calls  <code>mnesia:transaction</code> function.
Most of the commit coordination work is also done in the caller process.
This helps mnesia scale.
</p>


 <div id="orgeab7867" class="figure">
 <p> <object type="image/svg+xml" data="mnesia_trans.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>

 <div id="outline-container-orga4858da" class="outline-3">
 <h3 id="orga4858da"> <span class="section-number-3">1.1</span> Data structures</h3>
 <div class="outline-text-3" id="text-1-1">
</div>
 <div id="outline-container-org6768c91" class="outline-4">
 <h4 id="org6768c91"> <span class="section-number-4">1.1.1</span> What's inside mnesia_activity_state?</h4>
 <div class="outline-text-4" id="text-1-1-1">
 <p>
 <code>mnesia_activity_state</code> is a process dictionary variable in the transaction process.
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">transaction</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() -> <span style="color: #edd400; font-weight: bold; font-style: italic;"> </span> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({bar, 1, 2}),  <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 3, 3})  <span style="color: #729fcf; font-weight: bold;">end</span>).
....

{mnesia,
 # <span style="color: #8ae234; font-weight: bold;">tid</span>{counter = 13, pid = <0.125.0>},
 # <span style="color: #8ae234; font-weight: bold;">tidstore</span>{store = #Ref<0.3426409509.1642725377.222071>,
           up_stores = [],
           level = 1
           }}
</pre>
</div>

 <p>
Counter is the Lamport clock (kept by  <code>mnesia_tm</code> process)  <i>at the beginning</i> of the transaction.
</p>
</div>
</div>

 <div id="outline-container-org69775ce" class="outline-4">
 <h4 id="org69775ce"> <span class="section-number-4">1.1.2</span> What's inside the tidstore table?</h4>
 <div class="outline-text-4" id="text-1-1-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">transaction</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() -> <span style="color: #edd400; font-weight: bold; font-style: italic;"> </span> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({bar, 1, 2}),  <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 3, 3})  <span style="color: #729fcf; font-weight: bold;">end</span>).
....


[{{bar,1},{bar,1,2},write},
 {{foo,3},{foo,3,3}, write},
 {{locks,foo,3}, write},
 {{locks,bar,1}, write},
 {nodes,  <span style="color: #ad7fa8; font-style: italic;">'foo@me-emq'</span>},
 {nodes,  <span style="color: #ad7fa8; font-style: italic;">'bar@me-emq'</span>}]
</pre>
</div>
</div>
</div>
</div>

 <div id="outline-container-org83d3023" class="outline-3">
 <h3 id="org83d3023"> <span class="section-number-3">1.2</span>  <span class="todo TODO">TODO</span> Transactional reads and writes</h3>
 <div class="outline-text-3" id="text-1-2">

 <div id="org5495b46" class="figure">
 <p> <object type="image/svg+xml" data="mnesia_simplified.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

 <div id="outline-container-orgdfcf345" class="outline-3">
 <h3 id="orgdfcf345"> <span class="section-number-3">1.3</span> Commit process in detail</h3>
 <div class="outline-text-3" id="text-1-3">
 <p>
Commit procedure also mostly happens in the caller process.
This process acts as the coordinator.
</p>


 <div id="org79fbb64" class="figure">
 <p> <object type="image/svg+xml" data="mnesia_subscr.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>

 <div id="outline-container-orgb4664ca" class="outline-4">
 <h4 id="orgb4664ca"> <span class="section-number-4">1.3.1</span> Arrange</h4>
 <div class="outline-text-4" id="text-1-3-1">
 <p>
Arrange function is pretty convoluted.
Thankfully, it only uses the local data from the transaction store and the schema.
It creates a tuple of the following type:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">transaction</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() -> <span style="color: #edd400; font-weight: bold; font-style: italic;"> </span> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 1, 2}),  <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 3, 3})  <span style="color: #729fcf; font-weight: bold;">end</span>).
....

{2,
 # <span style="color: #8ae234; font-weight: bold;">prep</span>{protocol = sym_trans,
       records = [# <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,
                          decision = presume_commit,
                          ram_copies = [{{foo,1},{foo,1,2},write},
                                        {{foo,3},{foo,3,3},write}],
                          disc_copies = [],disc_only_copies = [],ext = [],
                          schema_ops = []},
                  # <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,decision = presume_commit,
                          ram_copies = [{{foo,1},{foo,1,2},write},
                                        {{foo,3},{foo,3,3},write}],
                          disc_copies = [],disc_only_copies = [],ext = [],
                          schema_ops = []}],
       prev_tab = foo,
       prev_types = [{ <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,ram_copies},
                     { <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,ram_copies}],
       prev_snmp = [],
       types = [{ <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,ram_copies},
                { <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,ram_copies}],
       majority = [],
       sync = false}}
</pre>
</div>

 <p>
The first element is the number of write/delete ops in the transaction.
This number is used to determine whether the transaction is r/o or r/w.
</p>
</div>
</div>

 <div id="outline-container-org669493a" class="outline-4">
 <h4 id="org669493a"> <span class="section-number-4">1.3.2</span> What is stored in the mnesia_tm's state?</h4>
 <div class="outline-text-4" id="text-1-3-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">transaction</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() -> <span style="color: #edd400; font-weight: bold; font-style: italic;"> </span> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 1, 2}),  <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 3, 3})  <span style="color: #729fcf; font-weight: bold;">end</span>).
....

# <span style="color: #8ae234; font-weight: bold;">state</span>{
    coordinators = {0,nil},
    participants =  <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Note: this field is a `</span> <span style="color: #729fcf; font-weight: bold;">gb_tree</span> <span style="color: #888a85;">'. So don't mind stuff in the outer tuple</span>
        {1,
         {# <span style="color: #8ae234; font-weight: bold;">tid</span>{counter = 32,pid = <11304.125.0>},
          # <span style="color: #8ae234; font-weight: bold;">participant</span>{
              tid = # <span style="color: #8ae234; font-weight: bold;">tid</span>{counter = 32,pid = <11304.125.0>},
              pid = nopid,
              commit =
                  # <span style="color: #8ae234; font-weight: bold;">commit</span>{
                      node =  <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,decision = presume_commit,
                      ram_copies =
                          [{{foo,1},{foo,1,2},write},{{foo,3},{foo,3,3},write}],
                      disc_copies = [],disc_only_copies = [],ext = [],
                      schema_ops = []},
              disc_nodes = [],
              ram_nodes = [ <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>, <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>],
              protocol = sym_trans},
          nil,nil}},
    supervisor = <0.99.0>,blocked_tabs = [],dirty_queue = [],
    fixed_tabs = []
  }
</pre>
</div>
</div>
</div>

 <div id="outline-container-org83bd18c" class="outline-4">
 <h4 id="org83bd18c"> <span class="section-number-4">1.3.3</span> What's stored in the mnesia log?</h4>
 <div class="outline-text-4" id="text-1-3-3">
 <p>
The contents of the  <code>#commit{}</code> record for the current node are written to the mnesia log:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">transaction</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() -> <span style="color: #edd400; font-weight: bold; font-style: italic;"> </span> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 1, 2}),  <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>({foo, 3, 3})  <span style="color: #729fcf; font-weight: bold;">end</span>).
....

# <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,
        decision = presume_commit,
        ram_copies = [{{foo,1},{foo,1,2},write},
                      {{foo,3},{foo,3,3},write}],
        disc_copies = [],
        disc_only_copies = [],
        ext = [],
        schema_ops = []
       }
</pre>
</div>

 <p>
Note that the commit is only logged on the node that initiated the transaction and the participant  <i>disk</i> nodes.
</p>
</div>
</div>
</div>
</div>

 <div id="outline-container-org4991d02" class="outline-2">
 <h2 id="org4991d02"> <span class="section-number-2">2</span>  <span class="todo TODO">TODO</span> Locker</h2>
</div>

 <div id="outline-container-org356b62c" class="outline-2">
 <h2 id="org356b62c"> <span class="section-number-2">3</span>  <span class="todo TODO">TODO</span> Schema</h2>
</div>

 <div id="outline-container-orgfabdc86" class="outline-2">
 <h2 id="orgfabdc86"> <span class="section-number-2">4</span>  <span class="todo TODO">TODO</span> Transaction aborts and restarts</h2>
</div>
 <div id="outline-container-orgcccfa58" class="outline-2">
 <h2 id="orgcccfa58"> <span class="section-number-2">5</span>  <span class="todo TODO">TODO</span> Dirty writes</h2>
 <div class="outline-text-2" id="text-5">

 <div id="orga3ecd08" class="figure">
 <p> <object type="image/svg+xml" data="mnesia_dirty_write.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>

 <div id="outline-container-org1eb4efd" class="outline-3">
 <h3 id="org1eb4efd"> <span class="section-number-3">5.1</span> Data structures</h3>
 <div class="outline-text-3" id="text-5-1">
</div>
 <div id="outline-container-orga7cdd35" class="outline-4">
 <h4 id="orga7cdd35"> <span class="section-number-4">5.1.1</span> What's inside #prep record?</h4>
 <div class="outline-text-4" id="text-5-1-1">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">dirty_write</span>({foo, 1, 1}).
....

# <span style="color: #8ae234; font-weight: bold;">prep</span>{protocol = async_dirty,
      records = [# <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,
                         decision = presume_commit,
                         ram_copies = [{{foo,1},{foo,1,1},write}],
                         disc_copies = [],disc_only_copies = [],ext = [],
                         schema_ops = []},
                 # <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,decision = presume_commit,
                         ram_copies = [{{foo,1},{foo,1,1},write}],
                         disc_copies = [],disc_only_copies = [],ext = [],
                         schema_ops = []}],
      prev_tab = foo,
      prev_types = [{ <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,ram_copies},
                    { <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,ram_copies}],
      prev_snmp = [],
      types = [{ <span style="color: #ad7fa8; font-style: italic;">'bar@localhost'</span>,ram_copies},
               { <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,ram_copies}],
      majority = [],sync = false}

</pre>
</div>
</div>
</div>

 <div id="outline-container-org5ffff57" class="outline-4">
 <h4 id="org5ffff57"> <span class="section-number-4">5.1.2</span> What is sent to the remote node?</h4>
 <div class="outline-text-4" id="text-5-1-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">dirty_write</span>({foo, 1, 1}).
....

{<11304.91.0>,
 {async_dirty,{dirty,<11304.91.0>},
              # <span style="color: #8ae234; font-weight: bold;">commit</span>{node =  <span style="color: #ad7fa8; font-style: italic;">'foo@me-emq'</span>,
                      decision = presume_commit,
                      ram_copies = [{{foo,1},{foo,1,1},write}],
                      disc_copies = [],
                      disc_only_copies = [],
                      ext = [],
                      schema_ops = []},
              foo}}
</pre>
</div>
</div>
</div>
</div>
</div>

 <div id="outline-container-org30d91c8" class="outline-2">
 <h2 id="org30d91c8"> <span class="section-number-2">6</span>  <span class="todo TODO">TODO</span> Scalability</h2>
 <div class="outline-text-2" id="text-6">
 <p>
As should be evident from the above diagram, transaction latency is expected to grow when the number of nodes in the cluster grows.
Indeed, we observed this effect in the test with the help of  <a href="https://www.man7.org/linux/man-pages/man8/tc-netem.8.html">netem</a>.
</p>
</div>
</div>
</div>]]></description>
  <link>https://blog.erlang.moe/2021-04-26-mnesia.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2021-04-26-mnesia.html</guid>
  <pubDate>m√•n, 26 apr 2021 02:00:00 +0200</pubDate>
</item>
<item>
  <title>Planning vs. prototyping</title>
  <description><![CDATA[<div id="content">

 <p>
The process of software engineering has two aspects: creative and
social. Neglecting the social aspect leads to products that nobody can
understand, support or use. Neglecting the creative aspect leads to
total waste of resources and products that never ship. In this post I
propose a simple formula that helps to strike the right balance
between the two.
</p>

 <p>
Let \(T_i\) is time needed to write the code demonstrating the approach,
\(T_r\) is time needed to rollback the code, if the approach does not
work, and \(T_d\) is time needed to discuss whether the approach will
work, then the following inequality must hold:
</p>

 <p>
\[
T_d \leq T_i + T_r
\]
</p>

 <p>
 <i>tagged: rant</i>
</p>
</div>]]></description>
  <link>https://blog.erlang.moe/2021-02-12-just-do-it.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2021-02-12-just-do-it.html</guid>
  <pubDate>fre, 12 feb 2021 01:00:00 +0100</pubDate>
</item>
<item>
  <title>This messenger respects your privacy</title>
  <description><![CDATA[<div id="content">

 <p>
Today I want to introduce Acme, a new instant messenger with E2E
encryption and blast processing, that respects your privacy! It's not
just for everyone, it is specifically targeted towards journalists who
need to communicate with their sources, dissidents and other people
 <del>whose metadata and social graph is especially interesting to
honeypot</del> in need of strong privacy. Forget about obsolete
decentralized stuff like GPG, and install AcmeIM from Grahma Play
Store today.
</p>

 <div id="outline-container-org5b005d2" class="outline-2">
 <h2 id="org5b005d2"> <span class="section-number-2">1</span> Mobile number</h2>
 <div class="outline-text-2" id="text-1">
 <p>
Unlike obsolete encryption systems, we require mobile phone to
register in our system. Your account is tied to your phone
number. Never mind that in many countries around the world SIM-cards
can be bought only after presenting a legal ID, and that mobile
networks themselves have all-encompassing LI (Lawful Interception)
interfaces by design. Also let's ignore the fact that mobile networks
still heavily rely on SS7 protocol stack from the 70s, with the
security model based on gentlemen's agreement. Some people claim that
words "mobile network" and "secure" can't be used in the same
sentence, but our security experts think it's very safe. Do you guys
not have phones?
</p>
</div>
</div>

 <div id="outline-container-orgf7c1831" class="outline-2">
 <h2 id="orgf7c1831"> <span class="section-number-2">2</span> Centralized</h2>
 <div class="outline-text-2" id="text-2">
 <p>
Our messenger uses client-server approach. (You can't run your own
server, BTW.) This allows us to iterate faster than the obsolete
p2p/federated networks. We promise not to store any metadata on our
servers. Remember, end-to-end encryption = safe.
</p>
</div>
</div>

 <div id="outline-container-org53d9200" class="outline-2">
 <h2 id="org53d9200"> <span class="section-number-2">3</span> Grahma play store</h2>
 <div class="outline-text-2" id="text-3">
 <p>
You can only download the client from the Grahma play store, so we can
iterate faster. Grahma inc. is the champion of privacy and freedom, so
we heavily rely on their APIs as well. It also helps us to update Acme
client automatically. Suppose some so-called experts "audited" certain
version of Acme. By doing that, they basically invited users to stick
to the old version and hinder our ability to evolve, and put our users
in risk. So we don't allow that.
</p>

 <p>
P.S. Grahma and friends  <i>certainly</i> don't have the list of apps
running on your phone, so it's safe to install AcmeIM without drawing
any attention.
</p>
</div>
</div>

 <div id="outline-container-org0b820a4" class="outline-2">
 <h2 id="org0b820a4"> <span class="section-number-2">4</span> Obsolete technologies</h2>
 <div class="outline-text-2" id="text-4">
 <p>
There are old cryptography tools that don't need centralized server,
or mobile phone. They are modular enough, so the cyphertext can be
embedded in DCT coefficients of cat pictures posted on @channel. In
the current year this approach is a joke. It is extremely user
unfriendly.
</p>

 <p>
Security experts proclaim these old tools obsolete and can't wait
until they die. Don't use them and download AcmeIM today!
</p>

 <p>
 <i>tagged: humor</i>
</p>
</div>
</div>
</div>]]></description>
  <link>https://blog.erlang.moe/2020-12-01-acme-messenger.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2020-12-01-acme-messenger.html</guid>
  <pubDate>tis, 01 dec 2020 01:00:00 +0100</pubDate>
</item>
<item>
  <title>Introduction to Snabbkaffe</title>
  <description><![CDATA[<div id="content">

 <p>
This is an HTML version of snabbkaffe presentation slides.
</p>

 <div id="outline-container-org7c8027f" class="outline-2">
 <h2 id="org7c8027f"> <span class="section-number-2">1</span> Background and motivation</h2>
 <div class="outline-text-2" id="text-1">
</div>
 <div id="outline-container-org5c9f4cc" class="outline-3">
 <h3 id="org5c9f4cc"> <span class="section-number-3">1.1</span> What is snabbkaffe</h3>
 <div class="outline-text-3" id="text-1-1">
 <ul class="org-ul"> <li>Snabbkaffe is a library that allows to test concurrent and distributed systems</li>

 <li>It does so by moving focus from  <i>states</i> to  <i>effects</i></li>

 <li>Developers find bugs by looking at the logs, snabbkaffe does the same and automates the process</li>

 <li>Advanced modes of testing: fault and scheduling injection</li>

 <li>Efficiency: run test scenario once, verify multiple properties</li>
</ul></div>
</div>

 <div id="outline-container-org8340ae9" class="outline-3">
 <h3 id="org8340ae9"> <span class="section-number-3">1.2</span> Name</h3>
 <div class="outline-text-3" id="text-1-2">
 <ul class="org-ul"> <li> <code>Snabbkaffe</code> means ``instant coffee'' in Swedish</li>

 <li>There is no hidden meaning, the name was chosen randomly</li>
</ul></div>
</div>

 <div id="outline-container-orga074e80" class="outline-3">
 <h3 id="orga074e80"> <span class="section-number-3">1.3</span> Nondeterminism</h3>
 <div class="outline-text-3" id="text-1-3">
</div>
 <ol class="org-ol"> <li> <a id="org74106dd"></a>Definitions <br></br> <div class="outline-text-4" id="text-1-3-1">
 <ul class="org-ul"> <li> <b>Deterministic</b> functions always produce the same output for the same input</li>

 <li> <b>Nondeterministic</b> functions can produce different outputs for the same input</li>
</ul></div>
</li>

 <li> <a id="org0da7467"></a>Sources of nondeterminism <br></br> <div class="outline-text-4" id="text-1-3-2">
 <ul class="org-ul"> <li>Process schedulings</li>

 <li>Fault-tolerance (failovers)</li>

 <li>Network (packet loss and reordering)</li>

 <li>Load balancing, worker pools</li>
</ul> <p>
Nondeterminism is an inherent property of concurrent systems
</p>
</div>
</li>
</ol></div>

 <div id="outline-container-org9b1fe2b" class="outline-3">
 <h3 id="org9b1fe2b"> <span class="section-number-3">1.4</span> Why change the paradigm of testing?</h3>
 <div class="outline-text-3" id="text-1-4">
</div>
 <ol class="org-ol"> <li> <a id="org11ef40a"></a>Difficulty levels <br></br> <div class="outline-text-4" id="text-1-4-1">
 <ol class="org-ol"> <li>Easy: Pure functions</li>

 <li>Normal: Stateful systems</li>

 <li>Hard: Nondeterministic systems</li>

 <li> <b>Nightmare:</b> Nondeterministic fault-tolerant distributed systems</li>
</ol></div>
</li>

 <li> <a id="orgc1bcec0"></a>Traditional approach <br></br> <div class="outline-text-4" id="text-1-4-2">
 <ul class="org-ul"> <li>Traditional approach is sufficient for testing pure functions.
There are a variety of excellent tools for this, like PropER</li>

 <li>It can do pretty well with stateful systems (stateful PropER)</li>

 <li> <b>Where it starts to crack:</b> typical Erlang application assembled together</li>
</ul></div>
</li>
</ol></div>

 <div id="outline-container-org050e423" class="outline-3">
 <h3 id="org050e423"> <span class="section-number-3">1.5</span> Challenges of testing Erlang applications  <i>in situ</i></h3>
 <div class="outline-text-3" id="text-1-5">
 <p>
Erlang partitions the state of the system between processes
</p>

 <ul class="org-ul"> <li>It eliminates some concurrency bugs and isolates failures</li>

 <li>But it makes the system harder to analyze</li>

 <li>More often than not it's impossible to inspect state of the process ( <code>sys:get_state</code>)</li>

 <li>Often it's useless</li>

 <li>Tests that rely on the state usually need to wait for the system to stabilize, it can be slow, and they can't analyze the system in motion</li>

 <li>Asynchronous data processing patterns (e.g. job queues) are incredibly annoying to test using traditional methods</li>
</ul></div>
</div>

 <div id="outline-container-orgd0f8ad2" class="outline-3">
 <h3 id="orgd0f8ad2"> <span class="section-number-3">1.6</span> Possible solution to this problem?</h3>
 <div class="outline-text-3" id="text-1-6">
 <p>
Move away from states and embrace events and their temporal relationships
</p>
</div>
</div>
</div>

 <div id="outline-container-org015130e" class="outline-2">
 <h2 id="org015130e"> <span class="section-number-2">2</span> Instrumenting the code</h2>
 <div class="outline-text-2" id="text-2">
</div>
 <div id="outline-container-org68fcd5e" class="outline-3">
 <h3 id="org68fcd5e"> <span class="section-number-3">2.1</span> Tracing macros</h3>
 <div class="outline-text-3" id="text-2-1">
 <ol class="org-ol"> <li>Replace your regular logs with structured logs (the industry is moving towards structured logs anyway)</li>

 <li>Include  <code>"snabbkaffe/include/trace.hrl"</code> header to your module</li>

 <li>Use  <code>?tp</code> or  <code>?tp_span</code> macros for logging ( <code>tp</code> stands for Trace Point)

 <ul class="org-ul"> <li>In the release build these macros will become regular  <code>logger</code> messages</li>

 <li>In the test build these macros will emit trace events</li>
</ul></li>
</ol></div>
</div>

 <div id="outline-container-orgefc2f9e" class="outline-3">
 <h3 id="orgefc2f9e"> <span class="section-number-3">2.2</span> Examples</h3>
 <div class="outline-text-3" id="text-2-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Disappears in the release build:</span>
? <span style="color: #8ae234;">tp</span>(rlog_replica_import_trans,
    #{ seqno       =>  <span style="color: #eeeeaa;">SeqNo</span>
     , txid        =>  <span style="color: #eeeeaa;">TXID</span>
     , transaction =>  <span style="color: #eeeeaa;">Transaction</span>
     })
</pre>
</div>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Becomes a notice message</span>
? <span style="color: #8ae234;">tp</span>(notice,  <span style="color: #ad7fa8; font-style: italic;">"Remote process died"</span>,
    #{ reason   =>  <span style="color: #eeeeaa;">Reason</span>
     , my_state =>  <span style="color: #eeeeaa;">State</span>
     })
</pre>
</div>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Emits two events:</span>
? <span style="color: #8ae234;">tp_span</span>(trans_write, #{record =>  <span style="color: #eeeeaa;">Record</span>, txid =>  <span style="color: #8ae234; font-weight: bold;">get_txid</span>()},
          <span style="color: #8ae234; font-weight: bold;">mnesia</span>: <span style="color: #8ae234; font-weight: bold;">write</span>( <span style="color: #eeeeaa;">Record</span>)).
</pre>
</div>
</div>
</div>

 <div id="outline-container-org47a7a89" class="outline-3">
 <h3 id="org47a7a89"> <span class="section-number-3">2.3</span> Distributed tracing</h3>
 <div class="outline-text-3" id="text-2-3">
 <p>
Forward traces from the remote node:
</p>
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">on the ct_master:</span>
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">forward_trace</span>( <span style="color: #eeeeaa;">Node</span>)
</pre>
</div>

 <p>
All features (incl. fault and scheduling injections) will work
</p>
</div>
</div>

 <div id="outline-container-org61f8401" class="outline-3">
 <h3 id="org61f8401"> <span class="section-number-3">2.4</span> Why not using erlang tracing?</h3>
 <div class="outline-text-3" id="text-2-4">
 <p>
An often asked question: why not using  <code>dbg:tracer</code> or the like?
</p>

 <p>
It was a conscious design choice:
</p>

 <ul class="org-ul"> <li>Traces obtained this way are tightly bound to the structure of the code. Refactoring the code or adding a new function argument would break the tests</li>

 <li>Debug traces are excessive, it would be hard to see the forest through the trees</li>

 <li>Log messages are typically placed in ``interesting'' places
 <ul class="org-ul"> <li>Interesting for humans = interesting for tests</li>
</ul></li>
</ul></div>
</div>
</div>

 <div id="outline-container-org8a211af" class="outline-2">
 <h2 id="org8a211af"> <span class="section-number-2">3</span> Testing</h2>
 <div class="outline-text-2" id="text-3">
</div>
 <div id="outline-container-org9012453" class="outline-3">
 <h3 id="org9012453"> <span class="section-number-3">3.1</span> Stages of the test</h3>
 <div class="outline-text-3" id="text-3-1">
 <p>
Every testcase is split in two stages:
</p>
</div>

 <ol class="org-ol"> <li> <a id="org785c726"></a>Run stage <br></br> <div class="outline-text-4" id="text-3-1-1">
 <p>
where the program runs and emits the event trace
</p>
</div>
</li>

 <li> <a id="orgffaf51c"></a>Check stage <br></br> <div class="outline-text-4" id="text-3-1-2">
 <p>
where the trace is collected as a list of Erlang maps and validated against the spec(s)
</p>
</div>
</li>
</ol></div>

 <div id="outline-container-org26aaf85" class="outline-3">
 <h3 id="org26aaf85"> <span class="section-number-3">3.2</span> check_trace macro</h3>
 <div class="outline-text-3" id="text-3-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #edd400; font-weight: bold; font-style: italic;">my_test</span>() ->
  ? <span style="color: #8ae234;">check_trace</span>( <span style="color: #729fcf; font-weight: bold;">begin</span>
                  <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Run stage:</span>
                  <span style="color: #8ae234; font-weight: bold;">launch_system</span>(),
                  <span style="color: #8ae234; font-weight: bold;">do_stuff</span>(),
                  <span style="color: #8ae234; font-weight: bold;">wait_for_completion</span>(),
                  <span style="color: #8ae234; font-weight: bold;">get_result</span>()
                <span style="color: #729fcf; font-weight: bold;">end</span>,
                <span style="color: #729fcf; font-weight: bold;">fun</span>( <span style="color: #eeeeaa;">Result</span>,  <span style="color: #eeeeaa;">Trace</span>) ->
                   <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check stage:</span>
                  ? <span style="color: #8ae234;">assertMatch</span>(ok,  <span style="color: #eeeeaa;">Result</span>),
                   <span style="color: #8ae234; font-weight: bold;">check_history</span>( <span style="color: #eeeeaa;">Trace</span>),
                   <span style="color: #8ae234; font-weight: bold;">check_history2</span>( <span style="color: #eeeeaa;">Trace</span>),
                  ...
                <span style="color: #729fcf; font-weight: bold;">end</span>).
</pre>
</div>
</div>
</div>

 <div id="outline-container-org813a077" class="outline-3">
 <h3 id="org813a077"> <span class="section-number-3">3.3</span> Waiting for events</h3>
 <div class="outline-text-3" id="text-3-3">
 <p>
It is possible to block run stage until a certain event occurs:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">block_until</span>(#{ ? <span style="color: #8ae234;">snk_kind</span>  := message_acked
              , message_id :=  <span style="color: #eeeeaa;">Id</span>
              }  <span style="color: #729fcf; font-weight: bold;">when</span>  <span style="color: #eeeeaa;">Id</span> > 42,
              <span style="color: #eeeeaa;">Timeout</span>,  <span style="color: #eeeeaa;">BackInTime</span>)
</pre>
</div>

 <p>
This macro will return immediately as soon as the event happens, so it's more efficient and less prone to flakiness than a sleep.
</p>
</div>
</div>

 <div id="outline-container-orge9a92fc" class="outline-3">
 <h3 id="orge9a92fc"> <span class="section-number-3">3.4</span> Starting an asynchronous action</h3>
 <div class="outline-text-3" id="text-3-4">
 <p>
 <code>?block_until</code> is fine, but it requires timeout tuning.
What if the same event happened in the past?
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">wait_async_action</span>(  <span style="color: #8ae234; font-weight: bold;">send_async_request</span>( <span style="color: #eeeeaa;">Req</span>)
                  , #{ ? <span style="color: #8ae234;">snk_kind</span> := request_handled
                     , request :=  <span style="color: #eeeeaa;">Req</span>
                     }
                 [,  <span style="color: #eeeeaa;">Timeout</span>]
                  )
</pre>
</div>

 <p>
This macro doesn't have to look into the past.
</p>
</div>
</div>

 <div id="outline-container-orgb1d87c3" class="outline-3">
 <h3 id="orgb1d87c3"> <span class="section-number-3">3.5</span> Integrating with PropER</h3>
 <div class="outline-text-3" id="text-3-5">
 <p>
It's not a problem to combine stateless PropER tests with snabbkaffe.
 <code>?check_trace</code> macro can be used inside proper's  <code>?FORALL</code> macro.
</p>

 <p>
Snabbkaffe provides some convenience macros that simplify trace-property-based testing:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #edd400; font-weight: bold; font-style: italic;">trace_prop_test</span>( <span style="color: #eeeeaa;">Config</span>) ->
   <span style="color: #eeeeaa;">Prop</span> = ? <span style="color: #8ae234;">forall_trace</span>(
             <span style="color: #eeeeaa;">X</span>,  <span style="color: #729fcf;">list</span>(),
             <span style="color: #729fcf; font-weight: bold;">begin</span>
               <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Run stage:</span>
               <span style="color: #8ae234; font-weight: bold;">do_stuff</span>( <span style="color: #eeeeaa;">X</span>)
             <span style="color: #729fcf; font-weight: bold;">end</span>,
             <span style="color: #729fcf; font-weight: bold;">fun</span>( <span style="color: #eeeeaa;">Result</span>,  <span style="color: #eeeeaa;">Trace</span>) ->
                 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check stage</span>
                true
             <span style="color: #729fcf; font-weight: bold;">end</span>),
  ? <span style="color: #8ae234;">run_prop</span>( <span style="color: #eeeeaa;">Config</span>,  <span style="color: #eeeeaa;">Prop</span>).
</pre>
</div>
</div>
</div>

 <div id="outline-container-org63c8075" class="outline-3">
 <h3 id="org63c8075"> <span class="section-number-3">3.6</span> Misc. macros</h3>
 <div class="outline-text-3" id="text-3-6">
 <p>
There are a few macros that are not directly related to trace-based testing, but often needed:
</p>
</div>

 <ol class="org-ol"> <li> <a id="org4f2d219"></a>?panic <br></br> <div class="outline-text-4" id="text-3-6-1">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">panic</span>( <span style="color: #ad7fa8; font-style: italic;">"Unexpected result"</span>, #{result =>  <span style="color: #eeeeaa;">A</span>})
</pre>
</div>

 <p>
Throw an error
</p>
</div>
</li>

 <li> <a id="org316fcc8"></a>?retry <br></br> <div class="outline-text-4" id="text-3-6-2">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">retry</span>( <span style="color: #eeeeaa;">_RetryPeriod</span> = 100,  <span style="color: #eeeeaa;">_MaxRetries</span> = 10,
        <span style="color: #8ae234; font-weight: bold;">some_action_that_can_fail</span>())
</pre>
</div>

 <p>
Run some code periodically until it succeeds (use as the last resort, when  <code>?block_until</code> won't work)
</p>
</div>
</li>

 <li> <a id="org03b7002"></a>?give_or_take <br></br> <div class="outline-text-4" id="text-3-6-3">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">give_or_take</span>( <span style="color: #eeeeaa;">_Expected</span> = 20,  <span style="color: #eeeeaa;">_Deviation</span> = 2,  <span style="color: #eeeeaa;">Value</span>)
</pre>
</div>

 <p>
Check that an integer value is within range
</p>
</div>
</li>
</ol></div>
</div>

 <div id="outline-container-org58fa320" class="outline-2">
 <h2 id="org58fa320"> <span class="section-number-2">4</span> Basic functions for working with traces</h2>
 <div class="outline-text-2" id="text-4">
</div>
 <div id="outline-container-org39aeb3b" class="outline-3">
 <h3 id="org39aeb3b"> <span class="section-number-3">4.1</span> Structure of the trace event</h3>
 <div class="outline-text-3" id="text-4-1">
 <div class="org-src-container">
 <pre class="src src-erlang">[#{ ? <span style="color: #8ae234;">snk_kind</span> => foo
  , ? <span style="color: #8ae234;">snk_meta</span> => #{ domain => [foo, bar]
                  , node =>  <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>
                  , time => <monotonic time>
                  , pid => <0.343.0>
                  , group_leader => <0.67.0>
                  , custom_field1 => baz
                  , custom_field2 => foobar
                  }
  , field1 => 42
  , field2 => foo
  },
  ...
]
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgaf6b726" class="outline-3">
 <h3 id="orgaf6b726"> <span class="section-number-3">4.2</span> Structure of the span trace</h3>
 <div class="outline-text-3" id="text-4-2">
 <div class="org-src-container">
 <pre class="src src-erlang">[#{ ? <span style="color: #8ae234;">snk_kind</span> => foo
  , ? <span style="color: #8ae234;">snk_meta</span> => #{ ... }
  , ? <span style="color: #8ae234;">snk_span</span> => start
  , field1 => 42
  , field2 => foo
  },
 #{ ? <span style="color: #8ae234;">snk_kind</span> => foo
  , ? <span style="color: #8ae234;">snk_meta</span> => #{ ... }
  , ? <span style="color: #8ae234;">snk_span</span> => {complete,  <span style="color: #eeeeaa;">ReturnValue</span>}
  , field1 => 42
  , field2 => foo
  }
]
</pre>
</div>
</div>
</div>


 <div id="outline-container-org1454246" class="outline-3">
 <h3 id="org1454246"> <span class="section-number-3">4.3</span> Filtering the trace</h3>
 <div class="outline-text-3" id="text-4-3">
</div>
 <ol class="org-ol"> <li> <a id="orgb554115"></a>?of_kind macro <br></br> <div class="outline-text-4" id="text-4-3-1">
 <div class="org-src-container">
 <pre class="src src-erlang">FooEvents = ? <span style="color: #8ae234;">of_kind</span>(foo,  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>

 <div class="org-src-container">
 <pre class="src src-erlang">FooOrBarEvents = ? <span style="color: #8ae234;">of_kind</span>([foo, bar],  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>
</div>
</li>

 <li> <a id="org3714279"></a>?of_domain macro <br></br> <div class="outline-text-4" id="text-4-3-2">
 <div class="org-src-container">
 <pre class="src src-erlang">EMQXEvents = ? <span style="color: #8ae234;">of_domain</span>([emqx| <span style="color: #eeeeaa;">_</span>],  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>
</div>
</li>

 <li> <a id="org8704cb5"></a>?of_node macro <br></br> <div class="outline-text-4" id="text-4-3-3">
 <div class="org-src-container">
 <pre class="src src-erlang">NodeFooEvents = ? <span style="color: #8ae234;">of_node</span>( <span style="color: #ad7fa8; font-style: italic;">'foo@localhost'</span>,  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>
</div>
</li>

 <li> <a id="org11711f6"></a>More complex filtering <br></br> <div class="outline-text-4" id="text-4-3-4">
 <p>
Of course,  <code>lists:filter</code> and list comprehensions work too
</p>
</div>
</li>
</ol></div>

 <div id="outline-container-org020de2d" class="outline-3">
 <h3 id="org020de2d"> <span class="section-number-3">4.4</span> Extracting fields</h3>
 <div class="outline-text-3" id="text-4-4">
 <div class="org-src-container">
 <pre class="src src-erlang">[1, 2] = ? <span style="color: #8ae234;">projection</span>(id, ? <span style="color: #8ae234;">of_kind</span>(handle_message,  <span style="color: #eeeeaa;">Trace</span>))
</pre>
</div>
 <div class="org-src-container">
 <pre class="src src-erlang">[{1,  <span style="color: #ad7fa8; font-style: italic;">"hello"</span>}, {2,  <span style="color: #ad7fa8; font-style: italic;">"world"</span>}] =
     ? <span style="color: #8ae234;">projection</span>( [id, message]
                , ? <span style="color: #8ae234;">of_kind</span>(handle_message,  <span style="color: #eeeeaa;">Trace</span>)
                )
</pre>
</div>
</div>
</div>
</div>

 <div id="outline-container-org0208a17" class="outline-2">
 <h2 id="org0208a17"> <span class="section-number-2">5</span> Event correlations</h2>
 <div class="outline-text-2" id="text-5">
</div>
 <div id="outline-container-org9cd002c" class="outline-3">
 <h3 id="org9cd002c"> <span class="section-number-3">5.1</span> ?strict_causality macro</h3>
 <div class="outline-text-3" id="text-5-1">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">strict_causality</span>( #{? <span style="color: #8ae234;">snk_kind</span> := msg_received, id :=  <span style="color: #eeeeaa;">_Id</span>}
                 , #{? <span style="color: #8ae234;">snk_kind</span> := msg_processed, id :=  <span style="color: #eeeeaa;">_Id</span>}
                 ,  <span style="color: #eeeeaa;">Trace</span>
                 )
</pre>
</div>

 <p>
Return value:
</p>

 <ul class="org-ul"> <li> <code>true</code> if some matching events were found</li>
 <li> <code>false</code> if no events were found</li>
 <li>exception if causality is violated</li>
</ul></div>
</div>

 <div id="outline-container-org64ff3ba" class="outline-3">
 <h3 id="org64ff3ba"> <span class="section-number-3">5.2</span> ?strict_causality with guard</h3>
 <div class="outline-text-3" id="text-5-2">
 <p>
Suppose we're testing a "base64 server":
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">strict_causality</span>( #{req :=  <span style="color: #eeeeaa;">_Req</span>}
                 , #{resp :=  <span style="color: #eeeeaa;">_Resp</span>}
                 ,  <span style="color: #eeeeaa;">_Resp</span> =:=  <span style="color: #8ae234; font-weight: bold;">base64</span>: <span style="color: #8ae234; font-weight: bold;">encode</span>( <span style="color: #eeeeaa;">_Req</span>)
                 ,  <span style="color: #eeeeaa;">Trace</span>
                 )
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgdfd16c7" class="outline-3">
 <h3 id="orgdfd16c7"> <span class="section-number-3">5.3</span> ?causality macro</h3>
 <div class="outline-text-3" id="text-5-3">
 <p>
Overall, it's the same as  <code>?strict_causality</code>, except it doesn't require each ``cause'' to have an ``effect''
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">causality</span>( #{? <span style="color: #8ae234;">snk_kind</span> := msg_received, id :=  <span style="color: #eeeeaa;">_Id</span>}
          , #{? <span style="color: #8ae234;">snk_kind</span> := msg_processed, id :=  <span style="color: #eeeeaa;">_Id</span>}
         [,  <span style="color: #eeeeaa;">Guard</span>]
          ,  <span style="color: #eeeeaa;">Trace</span>
          )
</pre>
</div>
</div>
</div>

 <div id="outline-container-org02aafe2" class="outline-3">
 <h3 id="org02aafe2"> <span class="section-number-3">5.4</span> Pitfalls</h3>
 <div class="outline-text-3" id="text-5-4">
 <p>
There is a potential problem with ``causality'' macros:
</p>

 <ol class="org-ol"> <li>Format of the event is changed in the code</li>
 <li>Match expressions in causality stop matching the events</li>
 <li>Tests still pass, even though they didn't find any events</li>
</ol> <p>
 <b>Solution:</b>
</p>

 <p>
Always wrap  <code>?causality</code> and  <code>?strict_causality</code> in  <code>?assert</code>, unless there are legit situations when no events can be produced in the test
</p>
</div>
</div>

 <div id="outline-container-orgb8f7886" class="outline-3">
 <h3 id="orgb8f7886"> <span class="section-number-3">5.5</span> ?find_pairs macro</h3>
 <div class="outline-text-3" id="text-5-5">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">find_pairs</span>( <span style="color: #eeeeaa;">Strict</span>,  <span style="color: #eeeeaa;">MatchCause</span>,  <span style="color: #eeeeaa;">MatchEffect</span> [,  <span style="color: #eeeeaa;">Guard</span>] ,  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>

 <ol class="org-ol"> <li>It returns a list of  <code>{pair, Cause, Effect}</code> or  <code>{singleton, Cause}</code></li>

 <li>When  <code>Strict</code> is  <code>true</code> this macro also checks that effects don't occur before causes (much like  <code>?causality</code>)</li>
</ol></div>
</div>

 <div id="outline-container-org04f763b" class="outline-3">
 <h3 id="org04f763b"> <span class="section-number-3">5.6</span> Splitting traces</h3>
 <div class="outline-text-3" id="text-5-6">
 <p>
Often it is useful to split traces to parts before and after some event (for example, restart)
</p>

 <p>
There are a variety of macros for this:
</p>
</div>

 <ol class="org-ol"> <li> <a id="org23b34c5"></a>split_at <br></br> <div class="outline-text-4" id="text-5-6-1">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">split_trace_at</span>(bar, [foo, bar, baz, bar]).
{[foo], [bar, baz, bar]}.
</pre>
</div>
</div>
</li>

 <li> <a id="org129cd9b"></a>splitr <br></br> <div class="outline-text-4" id="text-5-6-2">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">splitr_trace</span>(foo, [1, 2, foo, 1, 2, foo])
[[1, 2], [foo, 1, 2], [foo]].
</pre>
</div>
</div>
</li>

 <li> <a id="orga2e68ab"></a>splitl <br></br> <div class="outline-text-4" id="text-5-6-3">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">splitl_trace</span>(foo, [1, 2, foo, 1, 2, foo]).
[[1, 2, foo], [1, 2, foo]].
</pre>
</div>
</div>
</li>
</ol></div>
</div>

 <div id="outline-container-orgb8ef971" class="outline-2">
 <h2 id="orgb8ef971"> <span class="section-number-2">6</span> Nemesis</h2>
 <div class="outline-text-2" id="text-6">
</div>
 <div id="outline-container-org43e79c1" class="outline-3">
 <h3 id="org43e79c1"> <span class="section-number-3">6.1</span> Are your supervisors tested?</h3>
 <div class="outline-text-3" id="text-6-1">
 <ul class="org-ul"> <li>Taking fault-tolerance seriously is one of the selling points of Erlang.
Organizing processes in supervisor trees is used widely, but not often tested</li>

 <li>Tuning supervisor trees is an art</li>

 <li>Snabbkaffe wants to turn it into a chore</li>

 <li>It does so by injecting deliberate faults into the system</li>
</ul></div>
</div>

 <div id="outline-container-orgdb9c8c4" class="outline-3">
 <h3 id="orgdb9c8c4"> <span class="section-number-3">6.2</span> Fault injection</h3>
 <div class="outline-text-3" id="text-6-2">
 <p>
Any tracepoint can be used to inject errors into the system
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">inject_crash</span>( #{? <span style="color: #8ae234;">snk_meta</span> := #{domain := [ekka, rlog| <span style="color: #eeeeaa;">_</span>]}}
             ,  <span style="color: #8ae234; font-weight: bold;">snabbkaffe_nemesis</span>: <span style="color: #8ae234; font-weight: bold;">random_crash</span>(0.1)
             )

</pre>
</div>

 <ul class="org-ul"> <li>First argument: event matching expression</li>
 <li>Second argument: fault scenario</li>
</ul></div>
</div>

 <div id="outline-container-org8f325be" class="outline-3">
 <h3 id="org8f325be"> <span class="section-number-3">6.3</span> Fault scenarios</h3>
 <div class="outline-text-3" id="text-6-3">
</div>
 <ol class="org-ol"> <li> <a id="org6a8a274"></a>Always crash: <br></br> <div class="outline-text-4" id="text-6-3-1">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">inject_crash</span>(...,  <span style="color: #8ae234; font-weight: bold;">snabbkaffe_nemesis</span>: <span style="color: #8ae234; font-weight: bold;">always_crash</span>())
</pre>
</div>
</div>
</li>

 <li> <a id="org711705a"></a>Crash  <code>N</code> times: <br></br> <div class="outline-text-4" id="text-6-3-2">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">inject_crash</span>(...,  <span style="color: #8ae234; font-weight: bold;">snabbkaffe_nemesis</span>: <span style="color: #8ae234; font-weight: bold;">recover_after</span>(10))
</pre>
</div>
</div>
</li>

 <li> <a id="orgb482cf8"></a>Crash randomly with probability  <code>P</code>: <br></br> <div class="outline-text-4" id="text-6-3-3">
 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">inject_crash</span>(...,  <span style="color: #8ae234; font-weight: bold;">snabbkaffe_nemesis</span>: <span style="color: #8ae234; font-weight: bold;">random_crash</span>(0.1))
</pre>
</div>
</div>
</li>

 <li> <a id="org1523941"></a>Crash periodically: <br></br> <div class="outline-text-4" id="text-6-3-4">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">snabbkaffe_nemesis</span>: <span style="color: #8ae234; font-weight: bold;">periodic_crash</span>(
   <span style="color: #eeeeaa;">_Period</span> = 10,  <span style="color: #eeeeaa;">_DutyCycle</span> = 0.5,  <span style="color: #eeeeaa;">_Phase</span> =  <span style="color: #8ae234; font-weight: bold;">math</span>: <span style="color: #8ae234; font-weight: bold;">pi</span>())
</pre>
</div>
</div>
</li>
</ol></div>

 <div id="outline-container-orgcb3e463" class="outline-3">
 <h3 id="orgcb3e463"> <span class="section-number-3">6.4</span> Manipulating process schedulings</h3>
 <div class="outline-text-3" id="text-6-4">
 <ul class="org-ul"> <li>Sometimes it is necessary to test a certain process scheduling</li>

 <li>Imagine working on a bugfix using TDD-style</li>

 <li>For example, normally effect  <code>foo</code> occurs after effect  <code>bar</code>, and everything works.
But in rare cases the opposite happens, and the bug occurs</li>

 <li>Snabbkaffe can manipulate process schedulings to some extend:</li>
</ul> <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">run stage...</span>
? <span style="color: #8ae234;">force_ordering</span>(#{? <span style="color: #8ae234;">snk_kind</span> := bar}, #{? <span style="color: #8ae234;">snk_kind</span> := foo})
</pre>
</div>

 <p>
(It also supports guards)
</p>
</div>
</div>
</div>

 <div id="outline-container-org1a9e88b" class="outline-2">
 <h2 id="org1a9e88b"> <span class="section-number-2">7</span> Using snabbkaffe as a benchmark library</h2>
 <div class="outline-text-2" id="text-7">
</div>
 <div id="outline-container-org698d204" class="outline-3">
 <h3 id="org698d204"> <span class="section-number-3">7.1</span> Disclaimer</h3>
 <div class="outline-text-3" id="text-7-1">
 <ul class="org-ul"> <li>This usecase is a secondary, and quite rudimentary. Don't expect much</li>
 <li>It lacks many features of proper benchmarking libraries, such as
 <ul class="org-ul"> <li>Warmup</li>
 <li>Advanced statistical analysis, e.g. outlier detection</li>
</ul></li>
</ul></div>
</div>

 <div id="outline-container-orga1dee27" class="outline-3">
 <h3 id="orga1dee27"> <span class="section-number-3">7.2</span> Reporting metrics</h3>
 <div class="outline-text-3" id="text-7-2">
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Report a single scalar datapoint:</span>
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">push_stat</span>(scalar_metric_name,  <span style="color: #eeeeaa;">Value</span>),
 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Report a single datapoint with X coord:</span>
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">push_stat</span>(metric_name,  <span style="color: #eeeeaa;">X</span>,  <span style="color: #eeeeaa;">Value</span>),
 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Report multiple scalar datapoints:</span>
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">push_stats</span>(metric_name, [ <span style="color: #eeeeaa;">Val1</span>,  <span style="color: #eeeeaa;">Val2</span>, ...]),
 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Report multiple datapoints with X coord:</span>
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">push_stats</span>(metric_name,  <span style="color: #eeeeaa;">X</span>, [ <span style="color: #eeeeaa;">Val1</span>,  <span style="color: #eeeeaa;">Val2</span>, ...])
</pre>
</div>
</div>
</div>

 <div id="outline-container-org30b1ac1" class="outline-3">
 <h3 id="org30b1ac1"> <span class="section-number-3">7.3</span> Using spans to analyze performance</h3>
 <div class="outline-text-3" id="text-7-3">
 <p>
 <code>push_stats</code> function also works together with  <code>?find_pairs</code> macro:
</p>
 <div class="org-src-container">
 <pre class="src src-erlang">Pairs = ? <span style="color: #8ae234;">find_pairs</span>( #{ ? <span style="color: #8ae234;">snk_span</span> := start
                      , ? <span style="color: #8ae234;">snk_kind</span> := foo
                      , pid       :=  <span style="color: #eeeeaa;">_Pid</span>
                      }
                   , #{ ? <span style="color: #8ae234;">snk_span</span> := {complete,  <span style="color: #eeeeaa;">_</span>}
                      , ? <span style="color: #8ae234;">snk_kind</span> := foo
                      , pid       :=  <span style="color: #eeeeaa;">_Pid</span>
                      }
                   ),
 <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">push_stats</span>(metric_name, [ <span style="color: #eeeeaa;">X</span>,]  <span style="color: #eeeeaa;">Pairs</span>)
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgd6e1a06" class="outline-3">
 <h3 id="orgd6e1a06"> <span class="section-number-3">7.4</span> Analyzing the results</h3>
 <div class="outline-text-3" id="text-7-4">
 <p>
Use the following function in the end of check stage:
</p>
 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">analyze_statistics</span>()
</pre>
</div>

 <p>
It will print the results in the console:
</p>

 <pre class="example" id="org5d9b690">
Mean scalar_metric_name: 10.0

Statisitics of metric_name
100.479087 ^                                       *
           |                         *
           |                   *
           |
           |            *
           |      *
         0 +---------------------------------------->
           0                                     1100
</pre>
</div>
</div>
</div>

 <div id="outline-container-org7aa700d" class="outline-2">
 <h2 id="org7aa700d"> <span class="section-number-2">8</span> Conclusion</h2>
 <div class="outline-text-2" id="text-8">
</div>
 <div id="outline-container-orgd2c4f75" class="outline-3">
 <h3 id="orgd2c4f75"> <span class="section-number-3">8.1</span> Useful links</h3>
 <div class="outline-text-3" id="text-8-1">
 <p>
 <a href="https://github.com/kafka4beam/snabbkaffe">https://github.com/kafka4beam/snabbkaffe</a>
</p>

 <p>
The library is being actively developed.
</p>

 <p>
Suggestions, bug reports and patches are welcome!
</p>
</div>

 <ol class="org-ol"> <li> <a id="org4cc6410"></a>Snabbkaffe in action <br></br> <div class="outline-text-4" id="text-8-1-1">
 <p>
Feel free to use as an example (clickable links):
</p>

 <ul class="org-ul"> <li> <a href="https://github.com/kafka4beam/brod/blob/master/test/brod_group_subscriber_SUITE.erl">brod</a></li>

 <li> <a href="https://github.com/kafka4beam/kflow/tree/master/test">kflow</a></li>

 <li> <a href="https://github.com/k32/ekka/blob/master/test/ekka_mnesia_SUITE.erl">ekka</a></li>

 <li> <a href="https://github.com/emqx/emqx/">EMQ X</a></li>
</ul></div>
</li>
</ol></div>
</div>
</div>]]></description>
  <link>https://blog.erlang.moe/2021-04-25-snabbkaffe-slides.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2021-04-25-snabbkaffe-slides.html</guid>
  <pubDate>tis, 01 dec 2020 01:00:00 +0100</pubDate>
</item>
<item>
  <title>How to troubleshoot anything without a clue</title>
  <description><![CDATA[<div id="content">

 <p>
In this post I want to share some techniques that I adopted over the
years of troubleshooting large distributed systems. This list will be
updated as I come up with more useful generalizations. Disclaimer:
this article is heavily focused on platform-level development, so it
may not be fully applicable to other areas of software engineering.
</p>

 <p>
"In the ideal world this is absolutely impossible!", some of the
readers may exclaim in terror and disgust, "This is a bad
practice!". I will address their concerns in a chapter called "Have
zero trust in humanity".
</p>

 <p>
Although the need to troubleshoot anything mostly arises as a
consequence of human imperfection, it can be seen from a more positive
perspective. Imagine that you're using an open source product that
lacks certain feature. You want to implement this feature, but how to
approach a large, unfamiliar code base? Some techniques described
below will help to navigate through the unknown code more quickly.
</p>

 <div id="outline-container-orgc0bcdf6" class="outline-2">
 <h2 id="orgc0bcdf6"> <span class="section-number-2">1</span> Essential dos and don'ts</h2>
 <div class="outline-text-2" id="text-1">
</div>
 <div id="outline-container-orgf492f42" class="outline-3">
 <h3 id="orgf492f42"> <span class="section-number-3">1.1</span> Don't mess with the production</h3>
 <div class="outline-text-3" id="text-1-1">
 <p>
First and foremost: don't use debug tools in the production
environment. Debuggers or excessive logging put a lot of stress on the
system, so much so it will likely explode under normal traffic. There
are introspection tools that are  <i>more or less</i> safe to use in a live
environment, but one should be careful with those too. I'll discuss
some of these tools below.
</p>

 <p>
Logging in to a live system to run some sort of heavy debug job is
reckless enough already, but some large companies enforce even worse
practices.  Namely, they require developers to prepare a "debugging
runbook" for the ops team. Never agree to do this, unless you
personally supervise the process in real time. Here's why: suppose you
verified the instruction on a test node under simulated traffic, and
you know that it must finish in a couple seconds and the CPU load must
be so-and-so. Then you login to the production, and the same command
hangs for more than 10 seconds. You quickly realize that something
went horribly wrong, and use the last chance to abort the operation
before the server comes to a complete stop and your SSH session
dies. Another person won't react as quickly.
</p>
</div>
</div>

 <div id="outline-container-org076bf71" class="outline-3">
 <h3 id="org076bf71"> <span class="section-number-3">1.2</span> Syslog is your debugger</h3>
 <div class="outline-text-3" id="text-1-2">
 <p>
Learn how to debug without debugger. "Printf debugging" is considered
bad practice by some‚Ä¶ Lies. Whoever tells you that, wants to sell
you pro version of Visual Studio or something as useless. Truth is
that nowadays most serious systems are distributed. Stop-the-world
debugger that steps in and over functions won't work in the
distributed environment. Network sessions will time out and watchdog
will kill your service, if you try to stop it for debugging. And,
obviously, you can't stop a production system to debug a user request.
</p>

 <ul class="org-ul"> <li>Learn how to reason about the systems by reading logs and traces</li>
 <li>Make sure to log useful information</li>
 <li>Learn how to read and filter logs efficiently</li>
 <li>Learn how to quickly map log messages to the locations in the code</li>
 <li>Employ real-time log collection and indexing tools like
logstash/elasticsearch, Splunk, etc. in the production</li>
</ul></div>
</div>

 <div id="outline-container-orgb1df66b" class="outline-3">
 <h3 id="orgb1df66b"> <span class="section-number-3">1.3</span> Estimate urgency</h3>
 <div class="outline-text-3" id="text-1-3">
 <p>
Impact of software issues varies from "batch job is delayed, and
quality of service is slowly declining" to "company is losing  <code>$$$$/s</code>
 <i>right now</i>". Depending on the situation, more aggressive
troubleshooting techniques become appropriate.
</p>
</div>
</div>

 <div id="outline-container-org62866d1" class="outline-3">
 <h3 id="org62866d1"> <span class="section-number-3">1.4</span> Have they tried turning it off and on?</h3>
 <div class="outline-text-3" id="text-1-4">
 <p>
Don't underestimate the unreasonable effectiveness of
power-cycling. The ops team needs the run books describing how (and
when) to restart the misbehaving node.
</p>
</div>
</div>

 <div id="outline-container-orgc13dc22" class="outline-3">
 <h3 id="orgc13dc22"> <span class="section-number-3">1.5</span> Don't try to understand how things work</h3>
 <div class="outline-text-3" id="text-1-5">
 <p>
‚Ä¶and focus on finding why they  <i>don't work</i>.
</p>

 <p>
Another big mistake: trying to understand the entire code
base. Typical enterprise system consists of hundreds KLOC, not
counting dependencies and the underlying stack. It was written by
dozens of engineers over the years, and it interacts with a few other
services. It's just not a fair match against a single person working
under time pressure.  If you try to find out why error happens by
following the code ("a function that crashes is called from here,
where data comes from there"), you'll get lost very
quickly <sup> <a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. You can try this approach, and it  <i>may</i> work with the
most obvious bugs, but keep in mind that its complexity grows
rapidly. If you find yourself looking through more than, say, 5 source
code files at the same time, consider switching to more clever
techniques described below.
</p>

 <p>
Understanding how the system works  <i>will</i> be required later, when you
work on a "proper" solution, but during the peak firefighting stage
this knowledge is unobtainable, so you need to be prepared to perform
surgery without a clue.
</p>
</div>
</div>
</div>

 <div id="outline-container-org5f6cfa6" class="outline-2">
 <h2 id="org5f6cfa6"> <span class="section-number-2">2</span> Advanced techniques</h2>
 <div class="outline-text-2" id="text-2">
</div>
 <div id="outline-container-orgf8d757e" class="outline-3">
 <h3 id="orgf8d757e"> <span class="section-number-3">2.1</span> Differential troubleshooting</h3>
 <div class="outline-text-3" id="text-2-1">
 <p>
I find this technique absolutely essential for dealing with fires in
the companies' attics. It is simple, but exceedingly efficient. In
short, it's a way of reasoning based around questions:
</p>

 <ol class="org-ol"> <li>Anomaly was reported at 10am, what log messages appeared (or
disappeared) around this time?</li>
 <li>It worked before release R, and it doesn't work now. What is the
delta of the release R?</li>
 <li>It works with data A, but not data B. What is the delta between
requests A and B?</li>
 <li>‚Ä¶</li>
</ol> <p>
In other words, you need to find how the anomaly  <i>changes</i> the
behavior of the system. The more specific your questions become, the
smaller is your search space. Your goal is to narrow down the
difference between working and broken state of the system to the
smallest possible set.
</p>

 <p>
Importance of this method is based on the assumption that any
production system is  <i>mostly</i> correct in a sense that it exhibits
somewhat sane behavior in 90% of cases. If it was more broken than
that, nobody would expect it to work in the first place. Therefore,
trying to find an error simply by following the common code path is
fruitless, because this code path is  <i>most likely</i> correct.
</p>
</div>
</div>

 <div id="outline-container-orgbca95d3" class="outline-3">
 <h3 id="orgbca95d3"> <span class="section-number-3">2.2</span> Bisection</h3>
 <div class="outline-text-3" id="text-2-2">
 <p>
Typically requests have to travel through lots of individual services,
message brokers, functions and layers of abstraction. As usual,
bisection is the quickest method of pinpointing the place in the code
that corrupts the data. Instead of following the request from the
gateway proxy to the database, try to find what's going on
approximately in the middle between them. Is data already corrupted
there?
</p>
</div>
</div>

 <div id="outline-container-org0d9895b" class="outline-3">
 <h3 id="org0d9895b"> <span class="section-number-3">2.3</span> Surprisal maximization</h3>
 <div class="outline-text-3" id="text-2-3">
 <p>
Wikipedia gives the following definition of surprisal:
</p>

 <blockquote>
 <p>
The information content (also called the surprisal) of an event  <code>E</code> is
a function which decreases as the probability  <code>p(E)</code> of an event
increases.
</p>
</blockquote>

 <p>
When analyzing a broken request, or broken data, or broken code, try
finding the most distinct ("surprisal") part of it. Suppose you're
looking at some problematic data similar to this:
</p>

 <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"> <colgroup> <col class="org-left"></col> <col class="org-right"></col></colgroup> <tbody> <tr> <td class="org-left">id</td>
 <td class="org-right">345637</td>
</tr> <tr> <td class="org-left">code</td>
 <td class="org-right">3</td>
</tr> <tr> <td class="org-left">errandno</td>
 <td class="org-right">6422</td>
</tr></tbody></table> <p>
Grepping project sources for the field name "code" will likely yield
thousands of results. Searching for "id" will probably yield even
more. On the other hand, "errandno" field (whatever it means doesn't
matter) is pretty uncommon. It's not even an English word, which makes
it even better for our purposes. Search for "errandno" in the
company's source code index and you will likely find just 3 or 4
entries. One of them will point at the origin of the wrong data. Now
what about integer values? Searching for 3 in the logs will give you
millions of irrelevant results. So start from looking for
value 345637.
</p>

 <p>
I hope this example makes the idea pretty clear.
</p>
</div>
</div>
</div>

 <div id="outline-container-org69596f8" class="outline-2">
 <h2 id="org69596f8"> <span class="section-number-2">3</span> Tools</h2>
 <div class="outline-text-2" id="text-3">
 <p>
(To be extended)
</p>
</div>

 <div id="outline-container-org5813e52" class="outline-3">
 <h3 id="org5813e52"> <span class="section-number-3">3.1</span> Log index</h3>
 <div class="outline-text-3" id="text-3-1">
 <p>
Ideally, all logs should be collected in one place and
indexed. Logstash/elasticsearch/Kibana stack or Splunk are commonly
used for this.
</p>
</div>
</div>

 <div id="outline-container-org2a5fb70" class="outline-3">
 <h3 id="org2a5fb70"> <span class="section-number-3">3.2</span> Ag</h3>
 <div class="outline-text-3" id="text-3-2">
 <p>
 <a href="https://github.com/ggreer/the_silver_searcher">https://github.com/ggreer/the_silver_searcher</a> This tool helps to
navigate through the code, and it's blazing-fast (>100 kLOC project?
No problem.) I mostly use it via  <code>ag</code> Emacs plugin.
</p>
</div>
</div>

 <div id="outline-container-org2564ecf" class="outline-3">
 <h3 id="org2564ecf"> <span class="section-number-3">3.3</span> Source code index</h3>
 <div class="outline-text-3" id="text-3-3">
 <p>
Github, bitbucket and other source control servers index all the
code. Code search feature is essential for finding where error
messages come from, and for searching low-entropy data during
troubleshooting. Don't forget to use it.
</p>
</div>
</div>

 <div id="outline-container-orgbf993d2" class="outline-3">
 <h3 id="orgbf993d2"> <span class="section-number-3">3.4</span> Perf</h3>
 <div class="outline-text-3" id="text-3-4">
 <p>
Perf is a tool that is not  <i>too dangerous</i> to use in production.
</p>
</div>
</div>

 <div id="outline-container-org9f722b4" class="outline-3">
 <h3 id="org9f722b4"> <span class="section-number-3">3.5</span> Metrics</h3>
 <div class="outline-text-3" id="text-3-5">
 <p>
Of course you should have them.
</p>
</div>
</div>

 <div id="outline-container-org8bdb935" class="outline-3">
 <h3 id="org8bdb935"> <span class="section-number-3">3.6</span> strace/ltrace</h3>
 <div class="outline-text-3" id="text-3-6">
 <p>
I would not recommend running them in production. But these tools are
indispensable for local debugging.
</p>
</div>
</div>

 <div id="outline-container-org6237a75" class="outline-3">
 <h3 id="org6237a75"> <span class="section-number-3">3.7</span> tcpdump</h3>
 <div class="outline-text-3" id="text-3-7">
 <p>
Tcpdump is more or less safe to use in production (YMMV), but you must
filter by interface and port. Collect data to a local file and open it
with wireshark on your PC. Don't save capture file on any NFS mounts,
and don't print captured packets to the console attached by SSH,
unless you want to explore limits of infinite recursion.
</p>
</div>
</div>

 <div id="outline-container-orgb3c35d7" class="outline-3">
 <h3 id="orgb3c35d7"> <span class="section-number-3">3.8</span> system_monitor</h3>
 <div class="outline-text-3" id="text-3-8">
 <p>
If your system is written in Erlang or Elixir, consider using
 <a href="https://github.com/klarna-incubator/system_monitor">system_monitor</a> app. It was of tremendous help during many incidents.
</p>
</div>
</div>

 <div id="outline-container-org981eadd" class="outline-3">
 <h3 id="org981eadd"> <span class="section-number-3">3.9</span> Emacs "M-x occur" command</h3>
 <div class="outline-text-3" id="text-3-9">
 <p>
Emacs comes with a handy command called  <code>occur</code>. It does, quote:
</p>

 <blockquote>
 <p>
Show all lines in the current buffer containing a match for REGEXP.
If a match spreads across multiple lines, all those lines are shown.
</p>
</blockquote>

 <p>
Which is very useful for analyzing log files.
</p>
</div>
</div>
</div>

 <div id="outline-container-org8420213" class="outline-2">
 <h2 id="org8420213"> <span class="section-number-2">4</span> Have zero trust in humanity¬†¬†¬† <span class="tag"> <span class="rant">rant</span></span></h2>
 <div class="outline-text-2" id="text-4">
 <p>
If you find yourself dismissing some idea because your inner voice
says "well, this would be too obvious" or "no one could do something
like this", chances are that actually you are onto something. After
seeing bugs that no person should see, I conclude with all confidence,
that our industry is absolutely cursed. Self-made autodidacts and
university graduates alike have no idea how to do things. Putting your
trust in software engineer's ability to do something sane is like
expecting compensation from the Nigerian prince you helped to liberate
with the help of your new pen-friend.
</p>

 <p>
This raises a question: if nothing can be trusted, how to avoid
depth-first'ing into your entire OS and hardware stack? The answer
lies in differential troubleshooting technique described above. You
can suspect a bug in Linux. But if you do, it means the bug should
manifest not only in your business application, but in all other
processes running on the same host. If you don't observe anomalies in
the other processes, OS bug is less likely than application
bug. Bisection technique is also useful: if you suspect a Linux kernel
bug, run strace to find if data that goes into the kernel is valid
(most likely you will find that it's not).
</p>

 <p>
If you know OS and networking level well enough, and you practice
differential troubleshooting routine, your brain can generate and
dismiss potential failure scenarios in split second, so suspecting
services and libraries outside your own is not as time-consuming as
one may think.
</p>
</div>
</div>

 <div id="outline-container-org1d08549" class="outline-2">
 <h2 id="org1d08549"> <span class="section-number-2">5</span> Don't panic</h2>
 <div class="outline-text-2" id="text-5">
 <p>
When nothing works, try to get some company. The worst thing that can
happen is when you panic and stop trying new ideas. This happens even
to the best of us. Brainstorming helps a lot, but just having a
friendly chat, while something is burning, helps people staying
productive.
</p>
</div>
</div>

 <div id="outline-container-org42425bf" class="outline-2">
 <h2 id="org42425bf"> <span class="section-number-2">6</span> Nightmare difficulty: "Zero-knowledge troubleshooting"</h2>
 <div class="outline-text-2" id="text-6">
 <p>
Any bug is a cakewalk, when it concerns a system that you actively
develop. But I bet your company has Great Old Ones: systems that work
largely unnoticed, until they break. And things get much spicier when
you first learn about such system from a bug report with URGENT!
headline.
</p>

 <p>
I know, I know, situation like this could  <i>never</i> happen in the ideal
world. But if you're reading this post, then your plane of existence
intersects with mine. Be wary: in a hellish place that I inhibit,
people retire, change teams, and there are 10x rock star ninja
evangelists who develop something in spite of architect's advice just
to put it on their r√©sum√© and hop onto a next job. If you receive a
trouble report related to one of these systems, and have no idea what
it does and where it lives, don't worry too much. There is a person
who knows that: the one who submitted the bug report. Interrogate them
until you find some entry points towards the system. Learn hostnames,
keywords, what is the expected behavior, what behavior is unexpected,
and so forth. Then use source code index and all the techniques
described above.
</p>

 <p>
P.S. If you find yourself solving this kind of problem, don't forget
to look around and check if you're the last person left in the
office. Consider tactical retreat in the direction of job market.
</p>
</div>
</div>

 <div id="outline-container-org7ae80de" class="outline-2">
 <h2 id="org7ae80de"> <span class="section-number-2">7</span> Epilogue</h2>
 <div class="outline-text-2" id="text-7">
 <p>
This knowledge may ruin your life. If you master these techniques,
don't let anyone know, or else you may find yourself putting out
fires non-stop.
</p>

 <p>
The best way to apply your troubleshooting skills is by developing new
systems, rather than keeping legacy code on life support. Most
appropriate time for bug hunting is  <i>before</i> the software goes
live. Good troubleshooters make the best programmers, because they
learned from others' mistakes. They tend to design systems that are
more resilient to failure, and that are easier to troubleshoot. They
intuitively see scenarios that should be covered by tests. They
learned negative, pessimistic way of thinking, that is essential for
any platform-layer designer. Conversely, any person who can't
troubleshoot systems, can't be trusted to write platform-level code.
</p>

 <p>
Please note that I don't encourage you to program defensively, but
instead:
</p>

 <ul class="org-ul"> <li>Separate systems that should have AAA reliability from the systems
those code should be able to mutate quickly due to business
requirements</li>
 <li>Write good tests</li>
 <li>Design systems that have redundancy</li>
 <li>Design systems that are fail-safe</li>
 <li>Employ good deployment practices, like green/blue deployments</li>
 <li>Keep it simple, stupid. When you write a line of code, imagine that
someone has to troubleshoot it at 4 am, and they are good at
this. Which is to say, they  <i>will</i> find where you live.</li>
</ul></div>
</div>
 <div id="footnotes">
 <h2 class="footnotes">Footnotes: </h2>
 <div id="text-footnotes">

 <div class="footdef"> <sup> <a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"> <p class="footpara">
Especially when the code is written by a person who read
"Gang of Four" unironically
</p></div></div>


</div>
</div></div>]]></description>
  <link>https://blog.erlang.moe/2019-11-01-troubleshooting.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2019-11-01-troubleshooting.html</guid>
  <pubDate>s√∂n, 08 nov 2020 01:00:00 +0100</pubDate>
</item>
<item>
  <title>Trace-based testing</title>
  <description><![CDATA[<div id="content">

 <p>
Almost every practical algorithm is non-deterministic by
design. Unpredictable process scheduling has to be dealt with in
concurrent programs, network reorders and delays messages randomly,
and fault-tolerant systems can experience failover at any time. It
comes as no surprise to anyone, and most programmers deal with
non-determinism on subconscious level. Tests, on the other hand, often
ignore or fight this property, which becomes a constant supply of
flakiness.
</p>

 <p>
In this post I want to introduce a simple component <sup> <a id="fnr.1" class="footref" href="#fn.1">1</a></sup> test  <a href="https://github.com/klarna/snabbkaffe">library</a>
that tries to embrace non-determinism, or at least live with it. It
achieves this by giving up on  <i>states</i> and focusing on temporal
relations of  <i>effects</i> instead: relevant side effects of the algorithm
are recorded into a  <i>trace</i>, which later gets analyzed for desired
properties. Simply speaking, testcase reads the logs of system under
test (SUT) in order to find bugs. As a bonus, tests written in this
style tend to scale better than traditional ones, in theory and in my
own experience.
</p>

 <p>
The idea of using an event trace for verifying properties of
concurrent (and distributed) systems is far from new, but it is rather
uncommon outside of academia. I will also touch on how trace-based
testing compares with more traditional approaches such as stateful
property-based testing.
</p>

 <div id="outline-container-org97d6042" class="outline-2">
 <h2 id="org97d6042"> <span class="section-number-2">1</span> Conventional approach</h2>
 <div class="outline-text-2" id="text-1">
 <p>
Typical component test usually follows the same common scenario: first
a clean test environment is created. This probably involves spinning
up Docker containers, initializing tables with test data and so
on. Sometimes a testcase mocks functions that are of particular
interest, and injects checks inside these mocks. Then a SUT is
started. In the simplest case it happens synchronously, but often the
testcase has to wait for the steady state by probing, sleeping and
retrying.
</p>

 <p>
After startup is done, actual testing can finally begin. This part
consists of one or multiple iterations of stimulating the system (via
an API call or error injection), followed by checking that it responds
to the stimuli as expected. The checking part may again require
probing and retrying. It may also involve analyzing data captured by
the mocks.
</p>

 <p>
Finally a cleanup stage is run, but it is not that interesting. The
below pseudocode illustrates the entire workflow:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Preparations:</span>
 <span style="color: #edd400; font-weight: bold; font-style: italic;">set_up_test_environment</span>(),
 <span style="color: #edd400; font-weight: bold; font-style: italic;">mock_test_modules</span>(),
 <span style="color: #8ae234; font-weight: bold;">application</span>: <span style="color: #8ae234; font-weight: bold;">start</span>(tested_app),
 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Actual testing:</span>
? <span style="color: #8ae234;">assertMatch</span>(ok,  <span style="color: #8ae234; font-weight: bold;">async_action1</span>()),
 <span style="color: #edd400; font-weight: bold; font-style: italic;">retry_n_times</span>( <span style="color: #8ae234; font-weight: bold;">check_condition_1</span>()),
? <span style="color: #8ae234;">assertMatch</span>(ok,  <span style="color: #8ae234; font-weight: bold;">async_action2</span>()),
 <span style="color: #edd400; font-weight: bold; font-style: italic;">retry_n_times</span>( <span style="color: #8ae234; font-weight: bold;">check_condition_2</span>()),
? <span style="color: #8ae234;">assertMatch</span>({error,  <span style="color: #eeeeaa;">_</span>},  <span style="color: #8ae234; font-weight: bold;">async_action3</span>()),
 <span style="color: #edd400; font-weight: bold; font-style: italic;">retry_n_times</span>( <span style="color: #8ae234; font-weight: bold;">check_condition_3</span>()),
...
 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Clean up:</span>
 <span style="color: #8ae234; font-weight: bold;">application</span>: <span style="color: #8ae234; font-weight: bold;">stop</span>(tested_app),
 <span style="color: #edd400; font-weight: bold; font-style: italic;">tear_down_test_environment</span>()
</pre>
</div>

 <p>
This basic testing loop can be put together with varying degrees of
fanciness, up to stateful  <a href="https://proper-testing.github.io/">PropER</a> models, but it doesn't change the
core mechanic described above.
</p>

 <p>
So, what is wrong about this basic and familiar design?
</p>
</div>

 <div id="outline-container-org68d9d04" class="outline-3">
 <h3 id="org68d9d04"> <span class="section-number-3">1.1</span> Scalability</h3>
 <div class="outline-text-3" id="text-1-1">
 <p>
First problem is run time. Obviously, one wants to verify as many
different properties as possible. But a complex SUT may require a
complex test environment, which can take arbitrarily long time to set
up. (Anecdotally, I used to work with a Common Test suite where
 <code>init_per_testcase</code> callback took a few minutes. The experience was
soul-crushing.) Typical response to this challenge, naturally,
involves trying to cram as many scenarios into the testcase as
possible. Then comes realization that the testcase becomes extremely
hard to understand, troubleshoot and extend.
</p>

 <p>
In my experience, there are multiple reasons for this:
</p>

 <ol class="org-ol"> <li>State deviates too much from the blank slate. Each operation can
mutate state of the SUT, and the following checks have to take more
and more history into account. Stateful propER suites mitigate this
problem by managing model state automatically, but it comes at a
significant cost of having to define an elaborate and complete
model of the system.</li>
 <li> <p>
Non-determinism starts crawling out a closet. Typical test starts
from a known state, and tries to evolve it in extremely controlled
fashion, to avoid dealing with multiple outcomes, because there
lies combinatorial explosion and loss of sanity.
</p>

 <p>
But natural sources of randomness, that exist in any complex
system, tend to sneak into the results more and more over time. As
far as I know, stateful propERties can't deal with this, as model
state is evolved via symbolic execution that happens before SUT is
even started.
</p>

 <p>
This leads to testcase flakiness or unreasonably long waiting until
the system stabilizes.
</p></li>
 <li>Mocks are not composable. If checks are injected into SUT using
mock functions, it becomes exceedingly hard to add new checks.</li>
</ol> <p>
Conclusion: efficiency of testing could be greatly improved if there
was an easy way to validate multiple properties without re-running
test scenarios. Trace-based approach solves this problem, because an
event trace can be recorded once and analyzed however many times.
</p>
</div>
</div>

 <div id="outline-container-orga1d0569" class="outline-3">
 <h3 id="orga1d0569"> <span class="section-number-3">1.2</span> Error detection</h3>
 <div class="outline-text-3" id="text-1-2">
 <p>
"Retry N times until test condition becomes true and call it a pass"
is a pretty common pattern found in tests. Although it works
reasonably well most of the time, there are kinds of errors that evade
it: livelocks for example. During livelock condition the system may
enter "valid" state temporarily, and the testcase designed via retry
logic may accept it.
</p>

 <p>
To illustrate how bad it can be, imagine a distributed system
consisting of two nodes, where automatic failover can happen. Each
node can reside in three possible states, let's call them  <code>primary</code>,
 <code>standby</code> and  <code>alone</code>. During normal operation there is one  <code>primary</code>
and one  <code>standby</code> node. The  <code>primary</code> instance may fail, in which case
the other node changes its state from  <code>standby</code> to  <code>alone</code>, and takes
over the workload. When the failed node recovers, it enters  <code>standby</code>
state and signals to its partner that it's ready, then the latter
enters  <code>primary</code> state, and the system becomes redundant again. Now
suppose there is a bug, that is triggered shortly after state
transition from  <code>alone</code> to  <code>primary</code> happens. It can lead to a
situation where failover becomes cyclic. "Retry until first success"
approach will let this error slip through, but this error can be
trivially detected in a trace-based test by counting failover events.
</p>
</div>
</div>
</div>

 <div id="outline-container-org1310fde" class="outline-2">
 <h2 id="org1310fde"> <span class="section-number-2">2</span> Trace-based approach</h2>
 <div class="outline-text-2" id="text-2">
</div>
 <div id="outline-container-orgb28d20d" class="outline-3">
 <h3 id="orgb28d20d"> <span class="section-number-3">2.1</span> Prior work</h3>
 <div class="outline-text-3" id="text-2-1">
 <p>
The below (incomplete!) list contains some examples of libraries using
trace-based approach:
</p>

 <ul class="org-ul"> <li> <a href="https://github.com/uwplse/verdi">Verdi</a> is a framework for formal verification of distributed systems
using proofs over traces.</li>
 <li> <a href="https://github.com/jepsen-io/jepsen">Jepsen</a> is test framework for black-box testing of distributed
databases. Internally it maintains a log of calls towards SUT, and
most properties are verified by traversing this log (at least as
far as my ability to read Clojure goes).</li>
</ul></div>
</div>

 <div id="outline-container-org42f48c7" class="outline-3">
 <h3 id="org42f48c7"> <span class="section-number-3">2.2</span> Introducing Snabbkaffe</h3>
 <div class="outline-text-3" id="text-2-2">
 <p>
 <a href="https://github.com/klarna/snabbkaffe">Snabbkaffe</a> is a small Erlang application inspired by the above
libraries. Above all, it tries to be accessible and compatible with
other test frameworks, such as Common Test and PropER. It is not
rigorous <sup> <a id="fnr.2" class="footref" href="#fn.2">2</a></sup>: it can find bugs, but it cannot verify absence of
errors.
</p>
</div>
</div>

 <div id="outline-container-org4b3c892" class="outline-3">
 <h3 id="org4b3c892"> <span class="section-number-3">2.3</span> Instrumenting the code</h3>
 <div class="outline-text-3" id="text-2-3">
 <p>
Trace points are added to the code manually using  <code>?tp</code> macro:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">tp</span>(something_happened, #{ param1 =>  <span style="color: #ad7fa8; font-style: italic;">"Something"</span>
                         , param2 => 217
                         })
</pre>
</div>

 <p>
The above line of code, when compiled in test mode, emits an event of
kind  <code>something_happened</code>, with some additional data specified in the
second argument. Any event has a kind, which is an atom identifying
type of the event. The second argument must be a map that can contain
anything.
</p>

 <p>
Exact form of this effect captured in the trace will look like this:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">#{ kind   => something_happened
 , param1 =>  <span style="color: #ad7fa8; font-style: italic;">"Something"</span>
 , param2 => 217
 , ts     => .....  <span style="color: #888a85;">% </span> <span style="color: #888a85;">native timestamp</span>
 }
</pre>
</div>

 <p>
In the release build this macro will become a  <a href="https://github.com/tolbrino/hut">hut</a> log message with
debug level. Log level can be tuned with a special form of  <code>?tp</code> macro
that takes 3 arguments:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">tp</span>(notice, something_happened, #{ param1 =>  <span style="color: #ad7fa8; font-style: italic;">"Something"</span>
                                 , param2 => 217
                                 , ...
                                 })
</pre>
</div>

 <p>
‚Ä¶Quite literally, snabbkaffe analyzes the logs of the SUT.
</p>
</div>
</div>

 <div id="outline-container-org45e8709" class="outline-3">
 <h3 id="org45e8709"> <span class="section-number-3">2.4</span> Structure of the testcase</h3>
 <div class="outline-text-3" id="text-2-4">
 <p>
In order to address scalability issue mentioned above, snabbkaffe
decouples execution of test scenario from the checks. Testcases are
split in two parts:
</p>

 <ul class="org-ul"> <li> <b>Run stage</b> where the program runs and emits an event trace</li>
 <li> <b>Check stage</b> where the trace is collected and validated against
the spec(s)</li>
</ul> <p>
To save user from boilerplate of starting  <code>snabbkaffe_collector</code> and
collecting the trace,  <code>?check_trace</code> macro is defined, that takes care
of these steps:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">check_trace</span>( <span style="color: #729fcf; font-weight: bold;">begin</span>
                <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Run stage:</span>
                <span style="color: #eeeeaa;">Result</span>
              <span style="color: #729fcf; font-weight: bold;">end</span>,
              <span style="color: #729fcf; font-weight: bold;">fun</span>( <span style="color: #eeeeaa;">Result</span>,  <span style="color: #eeeeaa;">Trace</span>) ->
                 <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check stage:</span>
                 <span style="color: #eeeeaa;">CheckStage</span>
              <span style="color: #729fcf; font-weight: bold;">end</span>).
</pre>
</div>

 <p>
Return value of the run stage is passed to the check stage function
together with the collected trace.
</p>

 <p>
There is also an extended version of this macro, that passes some
additional options to  <code>snabbkaffe_collector</code>:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">check_trace</span>(#{timeout =>  <span style="color: #eeeeaa;">Timeout</span>},
              <span style="color: #729fcf; font-weight: bold;">begin</span>
                <span style="color: #eeeeaa;">RunStage</span>
              <span style="color: #729fcf; font-weight: bold;">end</span>,
              <span style="color: #729fcf; font-weight: bold;">fun</span>( <span style="color: #eeeeaa;">ReturnValue</span>,  <span style="color: #eeeeaa;">Trace</span>) ->
                 <span style="color: #eeeeaa;">CheckStage</span>
              <span style="color: #729fcf; font-weight: bold;">end</span>).
</pre>
</div>

 <p>
 <code>timeout</code> commands collector process to wait for a set period of
silence before terminating. It might be useful sometimes, although
depending on timeouts opens road to flakiness. There are a few other
parameters that are out of scope of this post.
</p>
</div>
</div>

 <div id="outline-container-org4dfc48e" class="outline-3">
 <h3 id="org4dfc48e"> <span class="section-number-3">2.5</span> Analyzing the trace</h3>
 <div class="outline-text-3" id="text-2-5">
 <p>
Remember that trace analysis is done offline, so any pure function can
be used for this task. Snabbakaffe comes with a few useful functions
and macros.
</p>

 <p>
Let's begin from my favorite one, called  <code>?strict_causality</code>. It
verifies that any event matching pattern  <code>Cause</code>, is followed by
exactly one event that matches pattern  <code>Effect</code>. It can be used to
encode "something results in another thing" type of properties, here's
just a few examples:
</p>

 <ul class="org-ul"> <li>Every external request entering the system eventually gets
processed</li>
 <li>Killing a node results in failover</li>
</ul> <p>
Consider an example:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">strict_causality</span>( #{kind := request, req_id :=  <span style="color: #eeeeaa;">_Ref</span>}  <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Cause</span>
                 , #{kind := reply,   req_id :=  <span style="color: #eeeeaa;">_Ref</span>}  <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Effect</span>
                 ,  <span style="color: #eeeeaa;">Trace</span>
                 )
</pre>
</div>

 <p>
 <code>Cause</code> expression binds variables used in  <code>Effect</code> expression, so the
above code reads as "for each request with request id equal to  <code>_Ref</code>
there should be a reply with the same id".
</p>

 <p>
There is also a sister macro that allows  <code>Cause</code> without  <code>Effect</code> (but
not vice versa), called  <code>?causality</code>. It works similarly, although it
is used less often. Both  <code>?strict_causality</code> and  <code>?causality</code> are
based on the same powerful macro called  <code>?find_pairs</code>:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">find_pairs</span>( <span style="color: #eeeeaa;">Strict</span>,  <span style="color: #eeeeaa;">Cause</span>,  <span style="color: #eeeeaa;">Effect</span> [,  <span style="color: #eeeeaa;">Guard</span>],  <span style="color: #eeeeaa;">Trace</span>)
</pre>
</div>

 <p>
Where  <code>Cause</code> and  <code>Effect</code> are pattern match expressions,  <code>Guard</code> is
an optional predicate that allows to refine cause/effect matching, and
 <code>Strict</code> is a boolean defining whether or not effects without a cause
are allowed. This macro returns a list of pairs of complimentary
events and singletons, that can be further analyzed, for example using
 <code>?pair_max_depth</code> macro, which returns maximal nesting level. This can
be used e.g. to verify semaphore-like systems.
</p>

 <p>
A few helper macros for extracting relevant data from the trace
deserve mention too.  <code>?of_kind([kind1, kind2, ...], Trace)</code>,
unsurprisingly, filters events with certain
kinds.  <code>?projection([field1, field2, ...], Trace)</code> extracts fields
from events to make data more manageable.
</p>

 <p>
 <code>?projection_complete</code> and  <code>?projection_is_subset</code> macros check if
values of a field form a superset or a subset of a known
set.  <code>snabbkaffe:unique/1</code> function checks that there are no duplicate
events.
</p>

 <p>
In general it is advised to factor complex properties into small
manageable functions, like in the below example (taken from a real
project and stripped of irrelevant details):
</p>

 <div class="org-src-container">
 <pre class="src src-erlang"> <span style="color: #edd400; font-weight: bold; font-style: italic;">my_testcase</span>( <span style="color: #eeeeaa;">Config</span>) ->
   <span style="color: #eeeeaa;">Values</span> = ...,
  ? <span style="color: #8ae234;">check_trace</span>(
      <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Run stage:</span>
      <span style="color: #729fcf; font-weight: bold;">begin</span>
        ...
      <span style="color: #729fcf; font-weight: bold;">end</span>,
      <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check stage:</span>
      <span style="color: #729fcf; font-weight: bold;">fun</span>( <span style="color: #eeeeaa;">_Ret</span>,  <span style="color: #eeeeaa;">Trace</span>) ->
          <span style="color: #8ae234; font-weight: bold;">check_all_messages_were_received_once</span>( <span style="color: #eeeeaa;">Trace</span>,  <span style="color: #eeeeaa;">Values</span>),
          <span style="color: #8ae234; font-weight: bold;">check_handler_pids</span>( <span style="color: #eeeeaa;">Trace</span>)
      <span style="color: #729fcf; font-weight: bold;">end</span>).

 <span style="color: #edd400; font-weight: bold; font-style: italic;">check_all_messages_were_received_once</span>( <span style="color: #eeeeaa;">Trace</span>,  <span style="color: #eeeeaa;">ExpectedValues</span>) ->
   <span style="color: #eeeeaa;">Handled</span> = ? <span style="color: #8ae234;">of_kind</span>(handle_message,  <span style="color: #eeeeaa;">Trace</span>),
   <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check that all messages were handled:</span>
  ? <span style="color: #8ae234;">projection_complete</span>(value,  <span style="color: #eeeeaa;">Handled</span>,  <span style="color: #eeeeaa;">ExpectedValues</span>),
   <span style="color: #888a85;">%% </span> <span style="color: #888a85;">...and each message was handled only once:</span>
   <span style="color: #8ae234; font-weight: bold;">snabbkaffe</span>: <span style="color: #8ae234; font-weight: bold;">unique</span>( <span style="color: #eeeeaa;">Handled</span>).

 <span style="color: #edd400; font-weight: bold; font-style: italic;">check_handler_pids</span>( <span style="color: #eeeeaa;">Trace</span>) ->
   <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Check that all messages were handled by the same process:</span>
   <span style="color: #eeeeaa;">PidsOfWorkers</span> = ? <span style="color: #8ae234;">projection</span>(worker, ? <span style="color: #8ae234;">of_kind</span>(handle_message,  <span style="color: #eeeeaa;">Trace</span>)),
  ? <span style="color: #8ae234;">assertMatch</span>([ <span style="color: #eeeeaa;">_</span>],  <span style="color: #8ae234; font-weight: bold;">lists</span>: <span style="color: #8ae234; font-weight: bold;">usort</span>( <span style="color: #eeeeaa;">PidsOfWorkers</span>)).
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgbdb7034" class="outline-3">
 <h3 id="orgbdb7034"> <span class="section-number-3">2.6</span> Waiting for events</h3>
 <div class="outline-text-3" id="text-2-6">
 <p>
Run stage often needs to wait for something to happen. This can be
needed, for example, when some part of the system is activated
asynchronously. Retry loop will still work, of course, but sometimes
it's more convenient to wait for a certain trace event.  <code>?block_until</code>
macro can be used in this situation:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">check_trace</span>(
   <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Run stage:</span>
   <span style="color: #729fcf; font-weight: bold;">begin</span>
     <span style="color: #888a85;">%% </span> <span style="color: #888a85;">Some async oparation:</span>
     <span style="color: #729fcf;">spawn</span>( <span style="color: #729fcf; font-weight: bold;">fun</span>() ->
             <span style="color: #8ae234; font-weight: bold;">timer</span>: <span style="color: #8ae234; font-weight: bold;">sleep</span>(100),
            ? <span style="color: #8ae234;">tp</span>(started, #{ ... }),
            ...
           <span style="color: #729fcf; font-weight: bold;">end</span>),
     <span style="color: #eeeeaa;">Timeout</span> = infinity,
     <span style="color: #eeeeaa;">BackInTime</span> = 100,
    ? <span style="color: #8ae234;">block_until</span>(#{kind := started},  <span style="color: #eeeeaa;">Timeout</span>,  <span style="color: #eeeeaa;">BackInTime</span>),
    ...
   <span style="color: #729fcf; font-weight: bold;">end</span>,
  ...
</pre>
</div>

 <p>
 <code>?block_until</code> macro works like this: first it tries to find an event
in the history, going at most  <code>BackInTime</code> milliseconds into the
past. If this succeeds, execution continues immediately, otherwise
calling process gets blocked until the event arrives or crashes after
timeout.
</p>

 <p>
Although this macro can cover most scenarios, tuning two timings may
be tricky and error-prone. There is a more "atomic" version of this
macro, named  <code>?wait_async_action</code>, which doesn't have to look into the
past:
</p>

 <div class="org-src-container">
 <pre class="src src-erlang">? <span style="color: #8ae234;">wait_async_action</span>( <span style="color: #eeeeaa;">Action</span>,  <span style="color: #eeeeaa;">Match</span>,  <span style="color: #eeeeaa;">Timeout</span>)
</pre>
</div>

 <p>
It starts waiting for  <code>Action</code>'s expected outcome event  <code>Match</code> before
running it.
</p>
</div>
</div>

 <div id="outline-container-orga4fd7a2" class="outline-3">
 <h3 id="orga4fd7a2"> <span class="section-number-3">2.7</span> PropER integration</h3>
 <div class="outline-text-3" id="text-2-7">
 <p>
Snabbkaffe works nicely with PropER.  <code>?check_trace</code> macro can be used
to define stateless properties, and there is, in fact, a shortcut for
the most common way of doing this:  <code>?forall_trace</code>. But when it comes
to stateful properties, things get more interesting on the
philosophical layer.
</p>

 <p>
Stateful property based testing is an object of pride in the Erlang
community, and rightfully so. Nonetheless, I would argue that
trace-based approach is more efficient in the majority of cases. First
of all, remember that snabbkaffe strives to eliminate the state from
the equation and focus on effects. This makes trace-based and stateful
property-based testing almost mutually exclusive. For black-box and
gray-box testing <sup> <a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, side effects is all what matters, so
snabbkaffe fills this niche. On the other hand, stateful properties
are much better at increasing test coverage.
</p>

 <p>
The below table highlights some of the benefits of each solution:
</p>

 <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"> <colgroup> <col class="org-left"></col> <col class="org-left"></col> <col class="org-left"></col></colgroup> <thead> <tr> <th scope="col" class="org-left">¬†</th>
 <th scope="col" class="org-left">Stateful propER</th>
 <th scope="col" class="org-left">snabbkaffe</th>
</tr></thead> <tbody> <tr> <td class="org-left">Purpose</td>
 <td class="org-left">white-box</td>
 <td class="org-left">black and gray-box</td>
</tr> <tr> <td class="org-left">Can handle non-determinism</td>
 <td class="org-left">no</td>
 <td class="org-left">yes</td>
</tr> <tr> <td class="org-left">Elaborate model is needed</td>
 <td class="org-left">yes</td>
 <td class="org-left">not necessarily</td>
</tr> <tr> <td class="org-left">Can reliably explore all states of the system</td>
 <td class="org-left">yes, with good enough model</td>
 <td class="org-left">no</td>
</tr> <tr> <td class="org-left">Shrinking</td>
 <td class="org-left">yes</td>
 <td class="org-left">no</td>
</tr> <tr> <td class="org-left">Amount of boilerplate</td>
 <td class="org-left">high (need to define a lot of callbacks)</td>
 <td class="org-left">low</td>
</tr></tbody></table></div>
</div>
</div>


 <div id="outline-container-org9212283" class="outline-2">
 <h2 id="org9212283"> <span class="section-number-2">3</span> Future posts</h2>
 <div class="outline-text-2" id="text-3">
 <p>
Here's a teaser of what's coming:
</p>

 <ul class="org-ul"> <li>Declarative error injection</li>
 <li>Rigorous trace-based models using  <a href="https://github.com/parapluu/Concuerror">Concuerror</a></li>
</ul></div>
</div>
 <div id="footnotes">
 <h2 class="footnotes">Footnotes: </h2>
 <div id="text-footnotes">

 <div class="footdef"> <sup> <a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"> <p class="footpara">
Since test levels are defined somewhat vaguely, here by
"component test" I mean testing of an entire OTP application, complete
with its supervisor tree, application dependencies and external
services that this application is meant to communicate with
(e.g. databases).
</p></div></div>

 <div class="footdef"> <sup> <a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"> <p class="footpara">
But running it under Concuerror might partially mitigate
this
</p></div></div>

 <div class="footdef"> <sup> <a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"> <p class="footpara">
‚Ä¶And for your customers. They can't observe the internal
state of the system, but they sure care about side effects of their
actions!
</p></div></div>


</div>
</div></div>]]></description>
  <link>https://blog.erlang.moe/2019-10-11-hello-world.html</link>
  <guid isPermaLink="false">https://blog.erlang.moe/2019-10-11-hello-world.html</guid>
  <pubDate>fre, 11 okt 2019 02:00:00 +0200</pubDate>
</item>
</channel>
</rss>
